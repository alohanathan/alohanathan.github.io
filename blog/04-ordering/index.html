<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Java并发编程（四）并发三大特性-有序性</title><meta charset=utf-8><meta name=description content="Ladder@Java并发编程（四）并发三大特性-有序性 - 逃跑山羊生活志"><meta name=author content="逃跑山羊"><link rel=canonical href=https://www.hinathan.online/blog/04-ordering/><meta name=google-site-verification content="xxx"><link rel=alternate type=application/rss+xml href=https://www.hinathan.online/index.xml title=逃跑山羊生活志><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y3KQB3PB19"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y3KQB3PB19",{anonymize_ip:!1})}</script><meta property="og:title" content="Java并发编程（四）并发三大特性-有序性"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://www.hinathan.online/blog/04-ordering/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-01-21T19:20:16+08:00"><meta property="article:modified_time" content="2020-01-21T19:20:16+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java并发编程（四）并发三大特性-有序性"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://www.hinathan.online/blog/"},{"@type":"ListItem","position":3,"name":"Java并发编程（四）并发三大特性-有序性","item":"https://www.hinathan.online/blog/04-ordering/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java并发编程（四）并发三大特性-有序性","name":"Java并发编程（四）并发三大特性-有序性","description":"","keywords":["有序性","并发"],"articleBody":"有序性 即程序执行的顺序按照代码的先后顺序执行。JVM 存在指令重排，所以存在有序性问题。\n如何保证有序性 通过volatile关键字保证有序性。\n通过内存屏障保证有序性。\n通过synchronized关键字保证有序性。\n通过Lock保证有序性。\n有序性问题深入分析 public class ReOrderTest { private static int x = 0, y = 0; private static int a = 0, b = 0; public static void main(String[] args) throws InterruptedException { int i = 0; while (true) { i++; x = 0; y = 0; a = 0; b = 0; Thread thread1 = new Thread(() -\u003e { shortWait(20000); a = 1; x = b; }); Thread thread2 = new Thread(() -\u003e { b = 1; y = a; }); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(\"第\" + i + \"次（\" + x + \",\" + y + \")\"); if (x == 0 \u0026\u0026 y == 0) { break; } } } public static void shortWait(long interval) { long start = System.nanoTime(); long end; do { end = System.nanoTime(); } while (start + interval \u003e= end); } } 结果\n第13512次（0,1) 第13513次（1,0) 第13514次（1,0) 第13515次（0,1) 第13516次（0,1) 指令重排序 Java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。\n指令重排序的意义 JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。\n在编译器与CPU处理器中都能执行指令重排优化操作\nvolatile重排序规则 volatile禁止重排序场景 第二个操作是volatile写，不管第一个操作是什么都不会重排序 第一个操作是volatile读，不管第二个操作是什么都不会重排序 第一个操作是volatile写，第二个操作是volatile读，也不会发生重排序 内存屏障 JMM内存屏障插入策略 在每个volatile写操作的前面插入一个StoreStore屏障 在每个volatile写操作的后面插入一个StoreLoad屏障 在每个volatile读操作的后面插入一个LoadLoad屏障 在每个volatile读操作的后面插入一个LoadStore屏障 ​ JVM层面的内存屏障 在JSR规范中定义了4种内存屏障：\nLoadLoad屏障：（指令Load1; LoadLoad; Load2），在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。\nLoadStore屏障：（指令Load1; LoadStore; Store2），在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。\nStoreStore屏障：（指令Store1; StoreStore; Store2），在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。\nStoreLoad屏障：（指令Store1; StoreLoad; Load2），在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能\n由于x86只有store load可能会重排序，所以只有JSR的StoreLoad屏障对应它的mfence或lock前缀指令，其他屏障对应空操作\n硬件层内存屏障 硬件层提供了一系列的内存屏障 memory barrier / memory fence(Intel的提法)来提供一致性的能力。\n拿X86平台来说，有几种主要的内存屏障：\nlfence，是一种Load Barrier 读屏障 sfence, 是一种Store Barrier 写屏障 mfence, 是一种全能型的屏障，具备lfence和sfence的能力 Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。 内存屏障有两个能力 阻止屏障两边的指令重排序 刷新处理器缓存/冲刷处理器缓存 对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据；对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。\nLock前缀实现了类似的能力，它先对总线和缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的数据刷新回主内存。在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放。\n不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。\n","wordCount":"1777","inLanguage":"zh","datePublished":"2020-01-21T19:20:16+08:00","dateModified":"2020-01-21T19:20:16+08:00","author":{"@type":"Person","name":"逃跑山羊"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hinathan.online/blog/04-ordering/"},"publisher":{"@type":"Organization","name":"逃跑山羊生活志","logo":{"@type":"ImageObject","url":"https://www.hinathan.online/favicon.ico"}}}</script><link rel=icon href=/favicon.icon sizes=16x16><link rel=apple-touch-icon href=/favicon.icon><link rel=manifest href=/favicon.icon><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.e4397cb14af48e0d175e9e854177b50c687a81aaa505e7ec7c948717cea895bd.css integrity="sha256-5Dl8sUr0jg0XXp6FQXe1DGh6gaqlBefsfJSHF86olb0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>主页</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>学习杂记</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/art>山羊日记</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/story>故事汇</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/series>系列</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>历史文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>标签</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/alohanathan><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://www.instagram.com/alohanathan59><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"/></svg></a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Java并发编程（四）并发三大特性-有序性</h1></header><p><small>2020年1月21日&nbsp;· 1777 字&nbsp;· 4 分钟</small>
<small>·
<a href=https://www.hinathan.online/tags/%E6%9C%89%E5%BA%8F%E6%80%A7/>有序性</a>
<a href=https://www.hinathan.online/tags/%E5%B9%B6%E5%8F%91/>并发</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#有序性>有序性</a><ul><li></li></ul></li><li><a href=#有序性问题深入分析>有序性问题深入分析</a></li><li><a href=#指令重排序>指令重排序</a><ul><li><a href=#指令重排序的意义>指令重排序的意义</a></li><li><a href=#volatile重排序规则>volatile重排序规则</a></li><li><a href=#volatile禁止重排序场景>volatile禁止重排序场景</a></li></ul></li><li><a href=#内存屏障>内存屏障</a><ul><li><a href=#jmm内存屏障插入策略>JMM内存屏障插入策略</a></li><li><a href=#jvm层面的内存屏障>JVM层面的内存屏障</a></li><li><a href=#硬件层内存屏障>硬件层内存屏障</a></li></ul></li></ul></nav></div><section class=blog-content><h2 id=有序性>有序性</h2><p>即程序执行的顺序按照代码的先后顺序执行。<u>JVM 存在指令重排，所以存在有序性问题。</u></p><h4 id=如何保证有序性>如何保证有序性</h4><ul><li><p>通过<code>volatile</code>关键字保证有序性。</p></li><li><p>通过<code>内存屏障</code>保证有序性。</p></li><li><p>通过<code>synchronized</code>关键字保证有序性。</p></li><li><p>通过<code>Lock</code>保证有序性。</p></li></ul><h2 id=有序性问题深入分析>有序性问题深入分析</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReOrderTest</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> 0<span style=color:#f92672>,</span> y <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 0<span style=color:#f92672>,</span> b <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++;</span>
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            y <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            b <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            Thread thread1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                shortWait<span style=color:#f92672>(</span>20000<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                a <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                x <span style=color:#f92672>=</span> b<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>            Thread thread2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                b <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                y <span style=color:#f92672>=</span> a<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>            thread1<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            thread2<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            thread1<span style=color:#f92672>.</span><span style=color:#a6e22e>join</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            thread2<span style=color:#f92672>.</span><span style=color:#a6e22e>join</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;第&#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;次（&#34;</span> <span style=color:#f92672>+</span> x <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#f92672>+</span> y <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;)&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>x <span style=color:#f92672>==</span> 0 <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shortWait</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> interval<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> end<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            end <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>start <span style=color:#f92672>+</span> interval <span style=color:#f92672>&gt;=</span> end<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>第13512次<span style=color:#960050;background-color:#1e0010>（</span>0<span style=color:#f92672>,</span>1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>第13513次<span style=color:#960050;background-color:#1e0010>（</span>1<span style=color:#f92672>,</span>0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>第13514次<span style=color:#960050;background-color:#1e0010>（</span>1<span style=color:#f92672>,</span>0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>第13515次<span style=color:#960050;background-color:#1e0010>（</span>0<span style=color:#f92672>,</span>1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>第13516次<span style=color:#960050;background-color:#1e0010>（</span>0<span style=color:#f92672>,</span>1<span style=color:#f92672>)</span>
</span></span></code></pre></div><h2 id=指令重排序>指令重排序</h2><p>Java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p><h3 id=指令重排序的意义>指令重排序的意义</h3><p>JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p><p>在编译器与CPU处理器中都能执行指令重排优化操作</p><p><img src=https://img.hinathan.online/2025/07/28567.png alt></p><h3 id=volatile重排序规则>volatile重排序规则</h3><p><img src=https://img.hinathan.online/2025/07/28665.png alt></p><h3 id=volatile禁止重排序场景>volatile禁止重排序场景</h3><ol><li>第二个操作是volatile写，不管第一个操作是什么都不会重排序</li><li>第一个操作是volatile读，不管第二个操作是什么都不会重排序</li><li>第一个操作是volatile写，第二个操作是volatile读，也不会发生重排序</li></ol><h2 id=内存屏障>内存屏障</h2><h3 id=jmm内存屏障插入策略>JMM内存屏障插入策略</h3><ol><li>在每个volatile写操作的前面插入一个StoreStore屏障</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadStore屏障</li></ol><p>​ <img src=https://img.hinathan.online/2025/07/28670.png alt=0></p><h3 id=jvm层面的内存屏障>JVM层面的内存屏障</h3><p>在JSR规范中定义了4种内存屏障：</p><ul><li><p><strong>LoadLoad屏障</strong>：（指令Load1; LoadLoad; Load2），在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p></li><li><p><strong>LoadStore屏障</strong>：（指令Load1; LoadStore; Store2），在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p></li><li><p><strong>StoreStore屏障</strong>：（指令Store1; StoreStore; Store2），在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p></li><li><p><strong>StoreLoad屏障</strong>：（指令Store1; StoreLoad; Load2），在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p></li></ul><p>由于x86只有store load可能会重排序，所以只有JSR的StoreLoad屏障对应它的mfence或lock前缀指令，其他屏障对应空操作</p><h3 id=硬件层内存屏障>硬件层内存屏障</h3><p>硬件层提供了一系列的内存屏障 memory barrier / memory fence(Intel的提法)来提供一致性的能力。</p><p>拿X86平台来说，有几种主要的内存屏障：</p><ol><li>lfence，是一种Load Barrier 读屏障</li><li>sfence, 是一种Store Barrier 写屏障</li><li>mfence, 是一种全能型的屏障，具备lfence和sfence的能力</li><li>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。</li></ol><h4 id=内存屏障有两个能力>内存屏障有两个能力</h4><ol><li>阻止屏障两边的指令重排序</li><li>刷新处理器缓存/冲刷处理器缓存</li></ol><p>对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据；对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。</p><p>Lock前缀实现了类似的能力，它先对总线和缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的数据刷新回主内存。在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放。</p><p>不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。</p></section><div class=related-resources></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","alohanathan/alohanathan.github.io"),s.setAttribute("data-repo-id","R_kgDON4MTgw"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDON4MTg84Cocaw"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","zh-CN"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2025 <a href=https://www.hinathan.online>逃跑山羊生活志</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e.js integrity="sha512-z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg==" crossorigin=anonymous defer></script></html>