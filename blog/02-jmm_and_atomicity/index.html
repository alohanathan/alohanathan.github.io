<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Java并发编程（二）JMM&并发三大特性-原子性</title><meta charset=utf-8><meta name=description content="Ladder@Java并发编程（二）JMM&并发三大特性-原子性 - 逃跑山羊生活志"><meta name=author content="逃跑山羊"><link rel=canonical href=https://www.hinathan.online/blog/02-jmm_and_atomicity/><meta name=google-site-verification content="xxx"><link rel=alternate type=application/rss+xml href=https://www.hinathan.online/index.xml title=逃跑山羊生活志><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y3KQB3PB19"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y3KQB3PB19",{anonymize_ip:!1})}</script><meta property="og:title" content="Java并发编程（二）JMM&并发三大特性-原子性"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://www.hinathan.online/blog/02-jmm_and_atomicity/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-01-10T21:20:16+08:00"><meta property="article:modified_time" content="2020-01-10T21:20:16+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java并发编程（二）JMM&并发三大特性-原子性"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://www.hinathan.online/blog/"},{"@type":"ListItem","position":3,"name":"Java并发编程（二）JMM\u0026并发三大特性-原子性","item":"https://www.hinathan.online/blog/02-jmm_and_atomicity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java并发编程（二）JMM\u0026并发三大特性-原子性","name":"Java并发编程（二）JMM\u0026并发三大特性-原子性","description":"","keywords":["原子性","JMM"],"articleBody":"从三个角度分析 Java层面 Jvm层面 硬件层面 这部分理解并发的三大特性，JMM工作内存和主内存关系，知道多线程之间如何通信的，掌握volatile能保证可见性和有序性，CAS就可以了，后续JVM层面和硬件层面的分析（可以看完Java锁机制，常用的并发工具类，并发容器之后再来看JMM这块。）\n并发三大特性 并发编程Bug的源头：可见性、原子性和有序性问题\n原子性 一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作（64位处理器）。不采取任何的原子性保障措施的自增操作并不是原子性的。\n如何保证原子性 通过synchronized关键字保证原子性。 通过Lock保证原子性。 通过CAS保证原子性。 在 32 位的机器上对 long 型变量进行加减操作是否存在并发隐患？ 是的！在 32 位机器上对 long 型变量 进行简单的加减操作（例如 count++ 或 count += 1）存在明显的并发隐患。\nFor the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.\nWrites and reads of volatile long and double values are always atomic.\nWrites to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.\nSome implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.\nImplementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.\n对于 Java 编程语言的内存模型而言，对一个非 volatile 的 long 或 double 值的单次写入会被视为两次单独的写入操作：分别对该值的高32位和低32位进行写入。这可能导致某个线程看到的64位数值中，前32位来自某次写操作，而后32位却来自另一次写操作。\n对 volatile 修饰的 long 和 double 值的读写操作始终是原子性的。\n对引用类型（references）的读写操作始终是原子性的，无论它们具体是以32位还是64位的方式实现。\n某些 Java 虚拟机的实现出于便利，可能会将对64位的 long 或 double 值的一次写操作拆分成对两个连续32位数值的两次写操作。为了效率起见，这种行为是依赖于具体实现的；Java 虚拟机的实现可以自由选择将对 long 和 double 的写操作作为原子操作进行，或分为两部分进行。\n建议 Java 虚拟机的实现尽量避免对64位数值的写入进行拆分。同时建议程序员在声明共享的64位变量时使用 volatile 修饰，或正确地对程序进行同步，以避免潜在的问题。\nJava内存模型（JMM） JMM定义 Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。\nJMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的。\nJMM与硬件内存架构的关系 Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：\n内存交互操作 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：\nlock：锁定，作用于主内存的变量，把一个变量标识为一条线程独占状态。 read：读取，作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load：载入，作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use：使用，作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign：赋值，作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store：存储，作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write：写入，作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 unlock：解锁，作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read和load成对出现 store和write成对出现 其实很好理解，下面是具体的规则↓↓↓\n内存交互操作规则 Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：\n如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 ","wordCount":"2596","inLanguage":"zh","datePublished":"2020-01-10T21:20:16+08:00","dateModified":"2020-01-10T21:20:16+08:00","author":{"@type":"Person","name":"逃跑山羊"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hinathan.online/blog/02-jmm_and_atomicity/"},"publisher":{"@type":"Organization","name":"逃跑山羊生活志","logo":{"@type":"ImageObject","url":"https://www.hinathan.online/favicon.ico"}}}</script><link rel=icon href=/favicon.icon sizes=16x16><link rel=apple-touch-icon href=/favicon.icon><link rel=manifest href=/favicon.icon><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.e4397cb14af48e0d175e9e854177b50c687a81aaa505e7ec7c948717cea895bd.css integrity="sha256-5Dl8sUr0jg0XXp6FQXe1DGh6gaqlBefsfJSHF86olb0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>主页</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>学习杂记</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/art>山羊日记</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/story>故事汇</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/series>系列</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>历史文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>标签</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/alohanathan><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://www.instagram.com/alohanathan59><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"/></svg></a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Java并发编程（二）JMM&并发三大特性-原子性</h1></header><p><small>2020年1月10日&nbsp;· 2596 字&nbsp;· 6 分钟</small>
<small>·
<a href=https://www.hinathan.online/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/>原子性</a>
<a href=https://www.hinathan.online/tags/jmm/>JMM</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#从三个角度分析>从三个角度分析</a></li><li><a href=#并发三大特性>并发三大特性</a><ul><li><a href=#原子性>原子性</a></li></ul></li><li><a href=#java内存模型jmm>Java内存模型（JMM）</a><ul><li><a href=#jmm定义>JMM定义</a></li><li><a href=#jmm与硬件内存架构的关系>JMM与硬件内存架构的关系</a></li><li><a href=#内存交互操作>内存交互操作</a></li></ul></li></ul></nav></div><section class=blog-content><h2 id=从三个角度分析>从三个角度分析</h2><ol><li>Java层面</li><li>Jvm层面</li><li>硬件层面</li></ol><p>这部分理解并发的三大特性，JMM工作内存和主内存关系，知道多线程之间如何通信的，掌握<code>volatile</code>能保证可见性和有序性，<code>CAS</code>就可以了，后续JVM层面和硬件层面的分析（可以看完Java锁机制，常用的并发工具类，并发容器之后再来看JMM这块。）</p><h2 id=并发三大特性>并发三大特性</h2><p>并发编程Bug的源头：可见性、原子性和有序性问题</p><h3 id=原子性>原子性</h3><p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。在 Java 中，<u>对基本数据类型的变量的读取和赋值操作是原子性操作（64位处理器）。</u>不采取任何的原子性保障措施的自增操作并不是原子性的。</p><h4 id=如何保证原子性>如何保证原子性</h4><ul><li>通过<code>synchronized</code>关键字保证原子性。</li><li>通过<code>Lock</code>保证原子性。</li><li>通过<code>CAS</code>保证原子性。</li></ul><h4 id=在-32-位的机器上对-long-型变量进行加减操作是否存在并发隐患>在 32 位的机器上对 long 型变量进行加减操作是否存在并发隐患？</h4><p>是的！在 32 位机器上对 <strong>long 型变量</strong> 进行简单的加减操作（例如 <code>count++</code> 或 <code>count += 1</code>）存在明显的并发隐患。</p><blockquote><p>For the purposes of the Java programming language memory model, a single write to a non-volatile <code>long</code> or <code>double</code> value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.</p><p>Writes and reads of volatile <code>long</code> and <code>double</code> values are always atomic.</p><p>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.</p><p>Some implementations may find it convenient to divide a single write action on a 64-bit <code>long</code> or <code>double</code> value into two write actions on adjacent 32-bit values. For efficiency&rsquo;s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to <code>long</code> and <code>double</code> values atomically or in two parts.</p><p>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as <code>volatile</code> or synchronize their programs correctly to avoid possible complications.</p></blockquote><blockquote><p>对于 Java 编程语言的内存模型而言，对一个非 volatile 的 long 或 double 值的单次写入会被视为两次单独的写入操作：分别对该值的高32位和低32位进行写入。这可能导致某个线程看到的64位数值中，前32位来自某次写操作，而后32位却来自另一次写操作。</p><p>对 volatile 修饰的 long 和 double 值的读写操作始终是原子性的。</p><p>对引用类型（references）的读写操作始终是原子性的，无论它们具体是以32位还是64位的方式实现。</p><p>某些 Java 虚拟机的实现出于便利，可能会将对64位的 long 或 double 值的一次写操作拆分成对两个连续32位数值的两次写操作。为了效率起见，这种行为是依赖于具体实现的；Java 虚拟机的实现可以自由选择将对 long 和 double 的写操作作为原子操作进行，或分为两部分进行。</p><p>建议 Java 虚拟机的实现尽量避免对64位数值的写入进行拆分。同时建议程序员在声明共享的64位变量时使用 volatile 修饰，或正确地对程序进行同步，以避免潜在的问题。</p></blockquote><h2 id=java内存模型jmm>Java内存模型（JMM）</h2><h3 id=jmm定义>JMM定义</h3><p>Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。</p><p>JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程<code>如何</code>和<code>何时</code>可以看到由其他线程修改过后的共享变量的值，以及在必须时<code>如何同步</code>的访问共享变量。JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<u>JMM是围绕原子性、有序性、可见性展开的</u>。</p><p><img src=https://img.hinathan.online/2025/07/28523.png alt></p><h3 id=jmm与硬件内存架构的关系>JMM与硬件内存架构的关系</h3><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：</p><p><img src=https://img.hinathan.online/2025/07/42981.png alt></p><h3 id=内存交互操作>内存交互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，<code>Java内存模型定义了以下八种操作</code>来完成：</p><ul><li><code>lock</code>：锁定，作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li><code>read</code>：读取，作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li><code>load</code>：载入，作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><code>use</code>：使用，作用于工作内存的变量，把工作内存中的一个变量值传递给<code>执行引擎</code>，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><code>assign</code>：赋值，作用于工作内存的变量，它把一个从<code>执行引擎</code>接收到的值赋值给<code>工作内存</code>的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><code>store</code>：存储，作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li><code>write</code>：写入，作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li><li><code>unlock</code>：解锁，作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p><img src=https://img.hinathan.online/2025/07/27711.png alt></p><ul><li>read和load成对出现</li><li>store和write成对出现</li></ul><p>其实很好理解，下面是具体的规则↓↓↓</p><h4 id=内存交互操作规则>内存交互操作规则</h4><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul></section><div class=related-resources></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","alohanathan/alohanathan.github.io"),s.setAttribute("data-repo-id","R_kgDON4MTgw"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDON4MTg84Cocaw"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","zh-CN"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2025 <a href=https://www.hinathan.online>逃跑山羊生活志</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e.js integrity="sha512-z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg==" crossorigin=anonymous defer></script></html>