<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Java并发编程（三）并发三大特性-可见性</title><meta charset=utf-8><meta name=description content="Ladder@Java并发编程（三）并发三大特性-可见性 - 逃跑山羊生活志"><meta name=author content="逃跑山羊"><link rel=canonical href=https://www.hinathan.online/blog/03-visibility/><meta name=google-site-verification content="xxx"><link rel=alternate type=application/rss+xml href=https://www.hinathan.online/index.xml title=逃跑山羊生活志><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y3KQB3PB19"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y3KQB3PB19",{anonymize_ip:!1})}</script><meta property="og:title" content="Java并发编程（三）并发三大特性-可见性"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://www.hinathan.online/blog/03-visibility/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-01-15T22:20:16+08:00"><meta property="article:modified_time" content="2020-01-15T22:20:16+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java并发编程（三）并发三大特性-可见性"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://www.hinathan.online/blog/"},{"@type":"ListItem","position":3,"name":"Java并发编程（三）并发三大特性-可见性","item":"https://www.hinathan.online/blog/03-visibility/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java并发编程（三）并发三大特性-可见性","name":"Java并发编程（三）并发三大特性-可见性","description":"","keywords":["可见性","并发"],"articleBody":"可见性 当一个线程修改了共享变量的值，其他线程能够看到修改的值。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。\n如何保证可见性 通过 volatile 关键字保证可见性。 通过 内存屏障保证可见性。 通过 synchronized 关键字保证可见性。 通过 Lock保证可见性。 通过 final 关键字保证可见性 可见性问题深入分析 /** * -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp */ public class VisibilityTest { private boolean flag = true; public void refresh() { flag = false; System.out.println(Thread.currentThread().getName() + \"修改flag\"); } public void load() { System.out.println(Thread.currentThread().getName() + \"开始执行.....\"); int i = 0; while (flag) { i++; //TODO 业务逻辑 } System.out.println(Thread.currentThread().getName() + \"跳出循环: i=\" + i); } public static void main(String[] args) throws InterruptedException { VisibilityTest test = new VisibilityTest(); // 线程threadA模拟数据加载场景 Thread threadA = new Thread(test::load, \"threadA\"); threadA.start(); // 让threadA执行一会儿 Thread.sleep(1000); // 线程threadB通过flag控制threadA的执行时间 Thread threadB = new Thread(test::refresh, \"threadB\"); threadB.start(); } public static void shortWait(long interval) { long start = System.nanoTime(); long end; do { end = System.nanoTime(); } while (start + interval \u003e= end); } } 上面的例子存在可见性问题！\nJMM的内存可见性保证 什么时候刷主内存，线程执行结束刷回主内存吗？还是一旦更新完之后就立马刷主内存？本地内存什么时候会没有？\n按程序类型，Java程序的内存可见性保证可以分为下列3类：\n单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。 未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值。 未同步程序在JMM中执行时，整体上是无序的，其执行结果无法预知。 JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。 未同步程序在两个模型中的执行特性有如下几个差异 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行，比如正确同步的多线程程序在临界区内的重排序。 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。 顺序一致性模型保证对所有的内存读/写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性（32位处理器）。 volatile volatile的特性 可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性（基于这点，我们通过会认为volatile不具备原子性）。volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。 64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。\n有序性：对volatile修饰的变量的读写操作**前后加上各种特定的内存屏障来禁止指令重排序**来保障有序性。 在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。为了提供一种比锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：\n严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。\nvolatile写-读的内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。 volatile可见性实现原理 JMM内存交互层面实现 volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步回主内存，使用时必须从主内存刷新，由此保证volatile变量操作对多线程的可见性。\n硬件层面实现 通过lock前缀指令，会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。\nvolatile在hotspot的实现 字节码解释器实现 JVM中的字节码解释器(bytecodeInterpreter)，用C++实现了JVM指令。\nsrc/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp文件：\nif (cache-\u003eis_volatile()) { switch (tos_type) { case ztos: obj-\u003erelease_byte_field_put(field_offset, (STACK_INT(-1) \u0026 1)); // only store LSB break; case btos: obj-\u003erelease_byte_field_put(field_offset, STACK_INT(-1)); break; case ctos: obj-\u003erelease_char_field_put(field_offset, STACK_INT(-1)); break; case stos: obj-\u003erelease_short_field_put(field_offset, STACK_INT(-1)); break; case itos: obj-\u003erelease_int_field_put(field_offset, STACK_INT(-1)); break; case ftos: obj-\u003erelease_float_field_put(field_offset, STACK_FLOAT(-1)); break; case ltos: obj-\u003erelease_long_field_put(field_offset, STACK_LONG(-1)); break; case dtos: obj-\u003erelease_double_field_put(field_offset, STACK_DOUBLE(-1)); break; case atos: { oop val = STACK_OBJECT(-1); VERIFY_OOP(val); obj-\u003erelease_obj_field_put(field_offset, val); break; } default: ShouldNotReachHere(); } OrderAccess::storeload(); } 模板解释器实现 模板解释器(templateInterpreter)，其对每个指令都写了一段对应的汇编代码，启动时将每个指令与对应汇编代码入口绑定，可以说是效率做到了极致。\nsrc/hotspot/os_cpu 包含了不同cpu的方法实现\nsrc/hotspot/cpu/x86/templateTable_x86.cpp\nvoid TemplateTable::volatile_barrier(Assembler::Membar_mask_bits order_constraint) { // Helper function to insert a is-volatile test and memory barrier if (os::is_MP()) { // Not needed on single CPU __ membar(order_constraint); } } // 负责执行putfield或putstatic指令 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) { // ... // Check for volatile store __ testl(rdx, rdx); __ jcc(Assembler::zero, notVolatile); putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags); volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad | Assembler::StoreStore)); __ jmp(Done); __ bind(notVolatile); putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags); __ bind(Done); } src/hotspot/cpu/x86/assembler_x86.hpp\n// Serializes memory and blows flags void membar(Membar_mask_bits order_constraint) { // We only have to handle StoreLoad // x86平台只需要处理StoreLoad if (order_constraint \u0026 StoreLoad) { int offset = -VM_Version::L1_line_size(); if (offset \u003c -128) { offset = -128; } // 下面这两句插入了一条lock前缀指令: lock addl $0, $0(%rsp) lock(); // lock前缀指令 addl(Address(rsp, offset), 0); // addl $0, $0(%rsp) } } 在linux系统x86中的实现\nx86处理器中利用lock实现类似内存屏障的效果。\ninline void OrderAccess::loadload() { compiler_barrier(); } inline void OrderAccess::storestore() { compiler_barrier(); } inline void OrderAccess::loadstore() { compiler_barrier(); } inline void OrderAccess::storeload() { fence(); } inline void OrderAccess::acquire() { compiler_barrier(); } inline void OrderAccess::release() { compiler_barrier(); } inline void OrderAccess::fence() { // always use locked addl since mfence is sometimes expensive #ifdef AMD64 __asm__ volatile (\"lock; addl $0,0(%%rsp)\" : : : \"cc\", \"memory\"); #else __asm__ volatile (\"lock; addl $0,0(%%esp)\" : : : \"cc\", \"memory\"); #endif compiler_barrier(); } lock前缀指令的作用 确保后续指令执行的原子性。在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销。 LOCK前缀指令具有类似于内存屏障的功能，禁止该指令与前面和后面的读写指令重排序。 LOCK前缀指令会等待它之前所有的指令完成、并且所有缓冲的写操作写回内存(也就是将store buffer中的内容写入内存)之后才开始执行，并且根据缓存一致性协议，刷新store buffer的操作会导致其他cache中的副本失效。 汇编层面volatile的实现 添加下面的jvm参数查看之前可见性Demo的汇编指令\n-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp\n验证了可见性使用了lock前缀指令\n从硬件层面分析Lock前缀指令 《64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf》中有如下描述：\nThe 32-bit IA-32 processors support locked atomic operations on locations in system memory. These operations are typically used to manage shared data structures (such as semaphores, segment descriptors, system segments, or page tables) in which two or more processors may try simultaneously to modify the same field or flag. The processor uses three interdependent mechanisms for carrying out locked atomic operations:\n• Guaranteed atomic operations\n• Bus locking, using the LOCK# signal and the LOCK instruction prefix\n• Cache coherency protocols that ensure that atomic operations can be carried out on cached data structures (cache lock); this mechanism is present in the Pentium 4, Intel Xeon, and P6 family processors\n32位的IA-32处理器支持对系统内存中的位置进行锁定的原子操作。这些操作通常用于管理共享的数据结构(如信号量、段描述符、系统段或页表)，在这些结构中，两个或多个处理器可能同时试图修改相同的字段或标志。\n处理器使用三种相互依赖的机制来执行锁定的原子操作:\n有保证的原子操作 总线锁定，使用LOCK#信号和LOCK指令前缀 缓存一致性协议，确保原子操作可以在缓存的数据结构上执行(缓存锁);这种机制出现在Pentium 4、Intel Xeon和P6系列处理器中 ","wordCount":"3290","inLanguage":"zh","datePublished":"2020-01-15T22:20:16+08:00","dateModified":"2020-01-15T22:20:16+08:00","author":{"@type":"Person","name":"逃跑山羊"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hinathan.online/blog/03-visibility/"},"publisher":{"@type":"Organization","name":"逃跑山羊生活志","logo":{"@type":"ImageObject","url":"https://www.hinathan.online/favicon.ico"}}}</script><link rel=icon href=/favicon.icon sizes=16x16><link rel=apple-touch-icon href=/favicon.icon><link rel=manifest href=/favicon.icon><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.e4397cb14af48e0d175e9e854177b50c687a81aaa505e7ec7c948717cea895bd.css integrity="sha256-5Dl8sUr0jg0XXp6FQXe1DGh6gaqlBefsfJSHF86olb0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>主页</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>学习杂记</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/art>山羊日记</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/story>故事汇</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/series>系列</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>历史文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>标签</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/alohanathan><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://www.instagram.com/alohanathan59><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"/></svg></a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Java并发编程（三）并发三大特性-可见性</h1></header><p><small>2020年1月15日&nbsp;· 3290 字&nbsp;· 7 分钟</small>
<small>·
<a href=https://www.hinathan.online/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/>可见性</a>
<a href=https://www.hinathan.online/tags/%E5%B9%B6%E5%8F%91/>并发</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#可见性>可见性</a><ul><li><a href=#如何保证可见性>如何保证可见性</a></li><li><a href=#可见性问题深入分析>可见性问题深入分析</a></li></ul></li><li><a href=#jmm的内存可见性保证>JMM的内存可见性保证</a><ul><li><a href=#未同步程序在两个模型中的执行特性有如下几个差异>未同步程序在两个模型中的执行特性有如下几个差异</a></li><li><a href=#volatile>volatile</a></li><li><a href=#lock前缀指令的作用>lock前缀指令的作用</a></li><li><a href=#汇编层面volatile的实现>汇编层面volatile的实现</a></li><li><a href=#从硬件层面分析lock前缀指令>从硬件层面分析Lock前缀指令</a></li></ul></li></ul></nav></div><section class=blog-content><h2 id=可见性>可见性</h2><p>当一个线程修改了共享变量的值，其他线程能够看到修改的值。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。</p><h3 id=如何保证可见性>如何保证可见性</h3><ul><li>通过 <code>volatile</code> 关键字保证可见性。</li><li>通过 <code>内存屏障</code>保证可见性。</li><li>通过 <code>synchronized</code> 关键字保证可见性。</li><li>通过 <code>Lock</code>保证可见性。</li><li>通过 <code>final</code> 关键字保证可见性</li></ul><h3 id=可见性问题深入分析>可见性问题深入分析</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VisibilityTest</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>refresh</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;修改flag&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>load</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;开始执行.....&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>flag<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//TODO  业务逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;跳出循环: i=&#34;</span> <span style=color:#f92672>+</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        VisibilityTest test <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> VisibilityTest<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程threadA模拟数据加载场景
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Thread threadA <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span>test<span style=color:#f92672>::</span>load<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;threadA&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        threadA<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 让threadA执行一会儿
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>1000<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程threadB通过flag控制threadA的执行时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Thread threadB <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span>test<span style=color:#f92672>::</span>refresh<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;threadB&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        threadB<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shortWait</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> interval<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> end<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            end <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>start <span style=color:#f92672>+</span> interval <span style=color:#f92672>&gt;=</span> end<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>上面的例子存在可见性问题！</p><h2 id=jmm的内存可见性保证>JMM的内存可见性保证</h2><blockquote><p>什么时候刷主内存，线程执行结束刷回主内存吗？还是一旦更新完之后就立马刷主内存？本地内存什么时候会没有？</p></blockquote><p>按程序类型，Java程序的内存可见性保证可以分为下列3类：</p><ul><li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过<code>限制编译器和处理器的重排序</code>来为程序员提供内存可见性保证。</li><li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值。<ul><li>未同步程序在JMM中执行时，整体上是无序的，其执行结果无法预知。</li><li>JMM不保证<u>未同步程序的执行结果</u>与该程序<u>在顺序一致性模型中的执行结果</u>一致。</li></ul></li></ul><h3 id=未同步程序在两个模型中的执行特性有如下几个差异>未同步程序在两个模型中的执行特性有如下几个差异</h3><ol><li><code>顺序一致性模型</code>保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行，比如正确同步的多线程程序在临界区内的重排序。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li><li>顺序一致性模型保证对所有的内存读/写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性（32位处理器）。</li></ol><h3 id=volatile>volatile</h3><h4 id=volatile的特性>volatile的特性</h4><ul><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于<code>volatile++</code>这种复合操作不具有原子性（<u>基于这点，我们通过会认为volatile不具备原子性</u>）。volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。</li></ul><blockquote><p>64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。</p></blockquote><ul><li>有序性：对volatile修饰的变量的读写操作**<u>前后加上各种特定的内存屏障来禁止指令重排序</u>**来保障有序性。</li></ul><p>在<code>JSR-133</code>之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。为了提供一种比锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：</p><p><strong>严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。</strong></p><h4 id=volatile写-读的内存语义>volatile写-读的内存语义</h4><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li><li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</li></ul><h4 id=volatile可见性实现原理>volatile可见性实现原理</h4><h5 id=jmm内存交互层面实现>JMM内存交互层面实现</h5><p>volatile修饰的变量的<code>read、load、use</code>操作和<code>assign、store、write</code>必须是连续的，即修改后必须立即同步回主内存，使用时必须从主内存刷新，由此保证volatile变量操作对多线程的可见性。</p><h5 id=硬件层面实现>硬件层面实现</h5><p>通过<code>lock前缀指令</code>，会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。<u>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</u></p><h5 id=volatile在hotspot的实现>volatile在hotspot的实现</h5><h6 id=字节码解释器实现>字节码解释器实现</h6><p>JVM中的字节码解释器(bytecodeInterpreter)，用C++实现了JVM指令。</p><p><code>src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp</code>文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (cache<span style=color:#f92672>-&gt;</span>is_volatile()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (tos_type) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> ztos:
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_byte_field_put(field_offset, (STACK_INT(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>)); <span style=color:#75715e>// only store LSB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> btos:
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_byte_field_put(field_offset, STACK_INT(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> ctos:
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_char_field_put(field_offset, STACK_INT(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> stos:
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_short_field_put(field_offset, STACK_INT(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> itos:
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_int_field_put(field_offset, STACK_INT(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> ftos:
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_float_field_put(field_offset, STACK_FLOAT(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> ltos:
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_long_field_put(field_offset, STACK_LONG(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> dtos:
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_double_field_put(field_offset, STACK_DOUBLE(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> atos: {
</span></span><span style=display:flex><span>        oop val <span style=color:#f92672>=</span> STACK_OBJECT(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        VERIFY_OOP(val);
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>-&gt;</span>release_obj_field_put(field_offset, val);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ShouldNotReachHere();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    OrderAccess<span style=color:#f92672>::</span>storeload();
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h6 id=模板解释器实现>模板解释器实现</h6><p>模板解释器(<code>templateInterpreter</code>)，其对每个指令都写了一段对应的汇编代码，启动时将每个指令与对应汇编代码入口绑定，可以说是效率做到了极致。</p><p><code>src/hotspot/os_cpu</code> 包含了不同cpu的方法实现</p><p><code>src/hotspot/cpu/x86/templateTable_x86.cpp</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> TemplateTable<span style=color:#f92672>::</span>volatile_barrier(Assembler<span style=color:#f92672>::</span>Membar_mask_bits
</span></span><span style=display:flex><span>                                     order_constraint) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Helper function to insert a is-volatile test and memory barrier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (os<span style=color:#f92672>::</span>is_MP()) { <span style=color:#75715e>// Not needed on single CPU
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __ <span style=color:#a6e22e>membar</span>(order_constraint);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 负责执行putfield或putstatic指令
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> TemplateTable<span style=color:#f92672>::</span>putfield_or_static(<span style=color:#66d9ef>int</span> byte_no, <span style=color:#66d9ef>bool</span> is_static, RewriteControl rc) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	 <span style=color:#75715e>// Check for volatile store
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __ <span style=color:#a6e22e>testl</span>(rdx, rdx);
</span></span><span style=display:flex><span>    __ <span style=color:#a6e22e>jcc</span>(Assembler<span style=color:#f92672>::</span>zero, notVolatile);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
</span></span><span style=display:flex><span>    volatile_barrier(Assembler<span style=color:#f92672>::</span>Membar_mask_bits(Assembler<span style=color:#f92672>::</span>StoreLoad <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>                                                 Assembler<span style=color:#f92672>::</span>StoreStore));
</span></span><span style=display:flex><span>    __ <span style=color:#a6e22e>jmp</span>(Done);
</span></span><span style=display:flex><span>    __ <span style=color:#a6e22e>bind</span>(notVolatile);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    __ <span style=color:#a6e22e>bind</span>(Done);
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>src/hotspot/cpu/x86/assembler_x86.hpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Serializes memory and blows flags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>membar</span>(Membar_mask_bits order_constraint) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We only have to handle StoreLoad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// x86平台只需要处理StoreLoad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (order_constraint <span style=color:#f92672>&amp;</span> StoreLoad) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> offset <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>VM_Version<span style=color:#f92672>::</span>L1_line_size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>128</span>) {
</span></span><span style=display:flex><span>      offset <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>128</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 下面这两句插入了一条lock前缀指令: lock addl $0, $0(%rsp) 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    lock(); <span style=color:#75715e>// lock前缀指令
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    addl(Address(rsp, offset), <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// addl $0, $0(%rsp) 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在linux系统x86中的实现</p><p>x86处理器中利用lock实现类似内存屏障的效果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> OrderAccess<span style=color:#f92672>::</span>loadload()   { compiler_barrier(); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> OrderAccess<span style=color:#f92672>::</span>storestore() { compiler_barrier(); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> OrderAccess<span style=color:#f92672>::</span>loadstore()  { compiler_barrier(); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> OrderAccess<span style=color:#f92672>::</span>storeload()  { fence();            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> OrderAccess<span style=color:#f92672>::</span>acquire()    { compiler_barrier(); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> OrderAccess<span style=color:#f92672>::</span>release()    { compiler_barrier(); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> OrderAccess<span style=color:#f92672>::</span>fence() {
</span></span><span style=display:flex><span>   <span style=color:#75715e>// always use locked addl since mfence is sometimes expensive
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#ifdef AMD64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __asm__ <span style=color:#66d9ef>volatile</span> (<span style=color:#e6db74>&#34;lock; addl $0,0(%%rsp)&#34;</span> <span style=color:#f92672>:</span> <span style=color:#f92672>:</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;cc&#34;</span>, <span style=color:#e6db74>&#34;memory&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __asm__ <span style=color:#66d9ef>volatile</span> (<span style=color:#e6db74>&#34;lock; addl $0,0(%%esp)&#34;</span> <span style=color:#f92672>:</span> <span style=color:#f92672>:</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;cc&#34;</span>, <span style=color:#e6db74>&#34;memory&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  compiler_barrier();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=lock前缀指令的作用>lock前缀指令的作用</h3><ol><li>确保后续指令执行的原子性。在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销。</li><li>LOCK前缀指令具有类似于内存屏障的功能，禁止该指令与前面和后面的读写指令重排序。</li><li>LOCK前缀指令会等待它之前所有的指令完成、并且所有缓冲的写操作写回内存(也就是将store buffer中的内容写入内存)之后才开始执行，并且根据缓存一致性协议，刷新store buffer的操作会导致其他cache中的副本失效。</li></ol><h3 id=汇编层面volatile的实现>汇编层面volatile的实现</h3><p>添加下面的jvm参数查看之前可见性Demo的汇编指令</p><p><code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp</code></p><p><img src=https://img.hinathan.online/2025/07/343842034.png alt=343842034></p><p>验证了可见性使用了<strong>lock前缀指令</strong></p><h3 id=从硬件层面分析lock前缀指令>从硬件层面分析Lock前缀指令</h3><p>《64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf》中有如下描述：</p><blockquote><p>The 32-bit IA-32 processors support locked atomic operations on locations in system memory. These operations are typically used to manage shared data structures (such as semaphores, segment descriptors, system segments, or page tables) in which two or more processors may try simultaneously to modify the same field or flag. The processor uses three interdependent mechanisms for carrying out locked atomic operations:</p><p>• Guaranteed atomic operations</p><p>• Bus locking, using the LOCK# signal and the LOCK instruction prefix</p><p>• Cache coherency protocols that ensure that atomic operations can be carried out on cached data structures (cache lock); this mechanism is present in the Pentium 4, Intel Xeon, and P6 family processors</p></blockquote><p>32位的IA-32处理器支持对系统内存中的位置进行锁定的原子操作。这些操作通常用于管理共享的数据结构(如信号量、段描述符、系统段或页表)，在这些结构中，两个或多个处理器可能同时试图修改相同的字段或标志。</p><p>处理器使用三种相互依赖的机制来执行锁定的原子操作:</p><ul><li>有保证的原子操作</li><li>总线锁定，使用LOCK#信号和LOCK指令前缀</li><li>缓存一致性协议，确保原子操作可以在缓存的数据结构上执行(缓存锁);这种机制出现在Pentium 4、Intel Xeon和P6系列处理器中</li></ul></section><div class=related-resources></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","alohanathan/alohanathan.github.io"),s.setAttribute("data-repo-id","R_kgDON4MTgw"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDON4MTg84Cocaw"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","zh-CN"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2025 <a href=https://www.hinathan.online>逃跑山羊生活志</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e.js integrity="sha512-z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg==" crossorigin=anonymous defer></script></html>