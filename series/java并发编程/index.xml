<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java并发编程 on 逃跑山羊生活志</title><link>https://www.hinathan.online/series/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link><description>Recent content in Java并发编程 on 逃跑山羊生活志 created by</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>2017 逃跑山羊生活志 All rights reserved</copyright><lastBuildDate>Tue, 21 Jan 2020 19:20:16 +0800</lastBuildDate><atom:link href="https://www.hinathan.online/series/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Java并发编程（四）并发三大特性-有序性</title><link>https://www.hinathan.online/blog/04-ordering/</link><pubDate>Tue, 21 Jan 2020 19:20:16 +0800</pubDate><guid>https://www.hinathan.online/blog/04-ordering/</guid><description>&lt;h2 id="有序性">有序性&lt;/h2>
&lt;p>即程序执行的顺序按照代码的先后顺序执行。&lt;u>JVM 存在指令重排，所以存在有序性问题。&lt;/u>&lt;/p>
&lt;h4 id="如何保证有序性">如何保证有序性&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>通过&lt;code>volatile&lt;/code>关键字保证有序性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>内存屏障&lt;/code>保证有序性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>synchronized&lt;/code>关键字保证有序性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>Lock&lt;/code>保证有序性。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="有序性问题深入分析">有序性问题深入分析&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ReOrderTest&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">,&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">,&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread thread1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread&lt;span style="color:#f92672">(()&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shortWait&lt;span style="color:#f92672">(&lt;/span>20000&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> b&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread thread2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread&lt;span style="color:#f92672">(()&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread2&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">join&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread2&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">join&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;第&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;次（&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> y &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;)&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>x &lt;span style="color:#f92672">==&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">shortWait&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">long&lt;/span> interval&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nanoTime&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> end&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end &lt;span style="color:#f92672">=&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nanoTime&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>start &lt;span style="color:#f92672">+&lt;/span> interval &lt;span style="color:#f92672">&amp;gt;=&lt;/span> end&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>第13512次&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>0&lt;span style="color:#f92672">,&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第13513次&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>1&lt;span style="color:#f92672">,&lt;/span>0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第13514次&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>1&lt;span style="color:#f92672">,&lt;/span>0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第13515次&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>0&lt;span style="color:#f92672">,&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第13516次&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>0&lt;span style="color:#f92672">,&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="指令重排序">指令重排序&lt;/h2>
&lt;p>Java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。&lt;/p>
&lt;h3 id="指令重排序的意义">指令重排序的意义&lt;/h3>
&lt;p>JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。&lt;/p>
&lt;p>在编译器与CPU处理器中都能执行指令重排优化操作&lt;/p>
&lt;p>&lt;img src="https://img.hinathan.online/2025/07/28567.png" alt="">&lt;/p>
&lt;h3 id="volatile重排序规则">volatile重排序规则&lt;/h3>
&lt;p>&lt;img src="https://img.hinathan.online/2025/07/28665.png" alt="">&lt;/p>
&lt;h3 id="volatile禁止重排序场景">volatile禁止重排序场景&lt;/h3>
&lt;ol>
&lt;li>第二个操作是volatile写，不管第一个操作是什么都不会重排序&lt;/li>
&lt;li>第一个操作是volatile读，不管第二个操作是什么都不会重排序&lt;/li>
&lt;li>第一个操作是volatile写，第二个操作是volatile读，也不会发生重排序&lt;/li>
&lt;/ol>
&lt;h2 id="内存屏障">内存屏障&lt;/h2>
&lt;h3 id="jmm内存屏障插入策略">JMM内存屏障插入策略&lt;/h3>
&lt;ol>
&lt;li>在每个volatile写操作的前面插入一个StoreStore屏障&lt;/li>
&lt;li>在每个volatile写操作的后面插入一个StoreLoad屏障&lt;/li>
&lt;li>在每个volatile读操作的后面插入一个LoadLoad屏障&lt;/li>
&lt;li>在每个volatile读操作的后面插入一个LoadStore屏障&lt;/li>
&lt;/ol>
&lt;p>​ &lt;img src="https://img.hinathan.online/2025/07/28670.png" alt="0">&lt;/p>
&lt;h3 id="jvm层面的内存屏障">JVM层面的内存屏障&lt;/h3>
&lt;p>在JSR规范中定义了4种内存屏障：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>LoadLoad屏障&lt;/strong>：（指令Load1; LoadLoad; Load2），在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>LoadStore屏障&lt;/strong>：（指令Load1; LoadStore; Store2），在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>StoreStore屏障&lt;/strong>：（指令Store1; StoreStore; Store2），在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>StoreLoad屏障&lt;/strong>：（指令Store1; StoreLoad; Load2），在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>由于x86只有store load可能会重排序，所以只有JSR的StoreLoad屏障对应它的mfence或lock前缀指令，其他屏障对应空操作&lt;/p>
&lt;h3 id="硬件层内存屏障">硬件层内存屏障&lt;/h3>
&lt;p>硬件层提供了一系列的内存屏障 memory barrier / memory fence(Intel的提法)来提供一致性的能力。&lt;/p>
&lt;p>拿X86平台来说，有几种主要的内存屏障：&lt;/p>
&lt;ol>
&lt;li>lfence，是一种Load Barrier 读屏障&lt;/li>
&lt;li>sfence, 是一种Store Barrier 写屏障&lt;/li>
&lt;li>mfence, 是一种全能型的屏障，具备lfence和sfence的能力&lt;/li>
&lt;li>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。&lt;/li>
&lt;/ol>
&lt;h4 id="内存屏障有两个能力">内存屏障有两个能力&lt;/h4>
&lt;ol>
&lt;li>阻止屏障两边的指令重排序&lt;/li>
&lt;li>刷新处理器缓存/冲刷处理器缓存&lt;/li>
&lt;/ol>
&lt;p>对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据；对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。&lt;/p>
&lt;p>Lock前缀实现了类似的能力，它先对总线和缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的数据刷新回主内存。在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放。&lt;/p>
&lt;p>不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。&lt;/p></description></item><item><title>Java并发编程（三）并发三大特性-可见性</title><link>https://www.hinathan.online/blog/03-visibility/</link><pubDate>Wed, 15 Jan 2020 22:20:16 +0800</pubDate><guid>https://www.hinathan.online/blog/03-visibility/</guid><description>&lt;h2 id="可见性">可见性&lt;/h2>
&lt;p>当一个线程修改了共享变量的值，其他线程能够看到修改的值。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。&lt;/p>
&lt;h3 id="如何保证可见性">如何保证可见性&lt;/h3>
&lt;ul>
&lt;li>通过 &lt;code>volatile&lt;/code> 关键字保证可见性。&lt;/li>
&lt;li>通过 &lt;code>内存屏障&lt;/code>保证可见性。&lt;/li>
&lt;li>通过 &lt;code>synchronized&lt;/code> 关键字保证可见性。&lt;/li>
&lt;li>通过 &lt;code>Lock&lt;/code>保证可见性。&lt;/li>
&lt;li>通过 &lt;code>final&lt;/code> 关键字保证可见性&lt;/li>
&lt;/ul>
&lt;h3 id="可见性问题深入分析">可见性问题深入分析&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">VisibilityTest&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">refresh&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;修改flag&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">load&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;开始执行.....&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>flag&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//TODO 业务逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;跳出循环: i=&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> VisibilityTest test &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> VisibilityTest&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 线程threadA模拟数据加载场景
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Thread threadA &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread&lt;span style="color:#f92672">(&lt;/span>test&lt;span style="color:#f92672">::&lt;/span>load&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;threadA&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threadA&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 让threadA执行一会儿
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sleep&lt;/span>&lt;span style="color:#f92672">(&lt;/span>1000&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 线程threadB通过flag控制threadA的执行时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Thread threadB &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread&lt;span style="color:#f92672">(&lt;/span>test&lt;span style="color:#f92672">::&lt;/span>refresh&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#e6db74">&amp;#34;threadB&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threadB&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">shortWait&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">long&lt;/span> interval&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nanoTime&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> end&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end &lt;span style="color:#f92672">=&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nanoTime&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>start &lt;span style="color:#f92672">+&lt;/span> interval &lt;span style="color:#f92672">&amp;gt;=&lt;/span> end&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子存在可见性问题！&lt;/p>
&lt;h2 id="jmm的内存可见性保证">JMM的内存可见性保证&lt;/h2>
&lt;blockquote>
&lt;p>什么时候刷主内存，线程执行结束刷回主内存吗？还是一旦更新完之后就立马刷主内存？本地内存什么时候会没有？&lt;/p>
&lt;/blockquote>
&lt;p>按程序类型，Java程序的内存可见性保证可以分为下列3类：&lt;/p>
&lt;ul>
&lt;li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。&lt;/li>
&lt;li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过&lt;code>限制编译器和处理器的重排序&lt;/code>来为程序员提供内存可见性保证。&lt;/li>
&lt;li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值。
&lt;ul>
&lt;li>未同步程序在JMM中执行时，整体上是无序的，其执行结果无法预知。&lt;/li>
&lt;li>JMM不保证&lt;u>未同步程序的执行结果&lt;/u>与该程序&lt;u>在顺序一致性模型中的执行结果&lt;/u>一致。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="未同步程序在两个模型中的执行特性有如下几个差异">未同步程序在两个模型中的执行特性有如下几个差异&lt;/h3>
&lt;ol>
&lt;li>&lt;code>顺序一致性模型&lt;/code>保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行，比如正确同步的多线程程序在临界区内的重排序。&lt;/li>
&lt;li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。&lt;/li>
&lt;li>顺序一致性模型保证对所有的内存读/写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性（32位处理器）。&lt;/li>
&lt;/ol>
&lt;h3 id="volatile">volatile&lt;/h3>
&lt;h4 id="volatile的特性">volatile的特性&lt;/h4>
&lt;ul>
&lt;li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。&lt;/li>
&lt;li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于&lt;code>volatile++&lt;/code>这种复合操作不具有原子性（&lt;u>基于这点，我们通过会认为volatile不具备原子性&lt;/u>）。volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>有序性：对volatile修饰的变量的读写操作**&lt;u>前后加上各种特定的内存屏障来禁止指令重排序&lt;/u>**来保障有序性。&lt;/li>
&lt;/ul>
&lt;p>在&lt;code>JSR-133&lt;/code>之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。为了提供一种比锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：&lt;/p>
&lt;p>&lt;strong>严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。&lt;/strong>&lt;/p>
&lt;h4 id="volatile写-读的内存语义">volatile写-读的内存语义&lt;/h4>
&lt;ul>
&lt;li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。&lt;/li>
&lt;li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。&lt;/li>
&lt;/ul>
&lt;h4 id="volatile可见性实现原理">volatile可见性实现原理&lt;/h4>
&lt;h5 id="jmm内存交互层面实现">JMM内存交互层面实现&lt;/h5>
&lt;p>volatile修饰的变量的&lt;code>read、load、use&lt;/code>操作和&lt;code>assign、store、write&lt;/code>必须是连续的，即修改后必须立即同步回主内存，使用时必须从主内存刷新，由此保证volatile变量操作对多线程的可见性。&lt;/p>
&lt;h5 id="硬件层面实现">硬件层面实现&lt;/h5>
&lt;p>通过&lt;code>lock前缀指令&lt;/code>，会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。&lt;u>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。&lt;/u>&lt;/p>
&lt;h5 id="volatile在hotspot的实现">volatile在hotspot的实现&lt;/h5>
&lt;h6 id="字节码解释器实现">字节码解释器实现&lt;/h6>
&lt;p>JVM中的字节码解释器(bytecodeInterpreter)，用C++实现了JVM指令。&lt;/p>
&lt;p>&lt;code>src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp&lt;/code>文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (cache&lt;span style="color:#f92672">-&amp;gt;&lt;/span>is_volatile()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (tos_type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> ztos:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_byte_field_put(field_offset, (STACK_INT(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)); &lt;span style="color:#75715e">// only store LSB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> btos:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_byte_field_put(field_offset, STACK_INT(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> ctos:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_char_field_put(field_offset, STACK_INT(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> stos:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_short_field_put(field_offset, STACK_INT(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> itos:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_int_field_put(field_offset, STACK_INT(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> ftos:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_float_field_put(field_offset, STACK_FLOAT(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> ltos:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_long_field_put(field_offset, STACK_LONG(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> dtos:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_double_field_put(field_offset, STACK_DOUBLE(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> atos: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> oop val &lt;span style="color:#f92672">=&lt;/span> STACK_OBJECT(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> VERIFY_OOP(val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_obj_field_put(field_offset, val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ShouldNotReachHere();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OrderAccess&lt;span style="color:#f92672">::&lt;/span>storeload();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="模板解释器实现">模板解释器实现&lt;/h6>
&lt;p>模板解释器(&lt;code>templateInterpreter&lt;/code>)，其对每个指令都写了一段对应的汇编代码，启动时将每个指令与对应汇编代码入口绑定，可以说是效率做到了极致。&lt;/p>
&lt;p>&lt;code>src/hotspot/os_cpu&lt;/code> 包含了不同cpu的方法实现&lt;/p>
&lt;p>&lt;code>src/hotspot/cpu/x86/templateTable_x86.cpp&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> TemplateTable&lt;span style="color:#f92672">::&lt;/span>volatile_barrier(Assembler&lt;span style="color:#f92672">::&lt;/span>Membar_mask_bits
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_constraint) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Helper function to insert a is-volatile test and memory barrier
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (os&lt;span style="color:#f92672">::&lt;/span>is_MP()) { &lt;span style="color:#75715e">// Not needed on single CPU
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> __ &lt;span style="color:#a6e22e">membar&lt;/span>(order_constraint);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 负责执行putfield或putstatic指令
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> TemplateTable&lt;span style="color:#f92672">::&lt;/span>putfield_or_static(&lt;span style="color:#66d9ef">int&lt;/span> byte_no, &lt;span style="color:#66d9ef">bool&lt;/span> is_static, RewriteControl rc) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Check for volatile store
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> __ &lt;span style="color:#a6e22e">testl&lt;/span>(rdx, rdx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __ &lt;span style="color:#a6e22e">jcc&lt;/span>(Assembler&lt;span style="color:#f92672">::&lt;/span>zero, notVolatile);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volatile_barrier(Assembler&lt;span style="color:#f92672">::&lt;/span>Membar_mask_bits(Assembler&lt;span style="color:#f92672">::&lt;/span>StoreLoad &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assembler&lt;span style="color:#f92672">::&lt;/span>StoreStore));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __ &lt;span style="color:#a6e22e">jmp&lt;/span>(Done);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __ &lt;span style="color:#a6e22e">bind&lt;/span>(notVolatile);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __ &lt;span style="color:#a6e22e">bind&lt;/span>(Done);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>src/hotspot/cpu/x86/assembler_x86.hpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Serializes memory and blows flags
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">membar&lt;/span>(Membar_mask_bits order_constraint) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// We only have to handle StoreLoad
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// x86平台只需要处理StoreLoad
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (order_constraint &lt;span style="color:#f92672">&amp;amp;&lt;/span> StoreLoad) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>VM_Version&lt;span style="color:#f92672">::&lt;/span>L1_line_size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (offset &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">128&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">128&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 下面这两句插入了一条lock前缀指令: lock addl $0, $0(%rsp)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> lock(); &lt;span style="color:#75715e">// lock前缀指令
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> addl(Address(rsp, offset), &lt;span style="color:#ae81ff">0&lt;/span>); &lt;span style="color:#75715e">// addl $0, $0(%rsp)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在linux系统x86中的实现&lt;/p>
&lt;p>x86处理器中利用lock实现类似内存屏障的效果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OrderAccess&lt;span style="color:#f92672">::&lt;/span>loadload() { compiler_barrier(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OrderAccess&lt;span style="color:#f92672">::&lt;/span>storestore() { compiler_barrier(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OrderAccess&lt;span style="color:#f92672">::&lt;/span>loadstore() { compiler_barrier(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OrderAccess&lt;span style="color:#f92672">::&lt;/span>storeload() { fence(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OrderAccess&lt;span style="color:#f92672">::&lt;/span>acquire() { compiler_barrier(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OrderAccess&lt;span style="color:#f92672">::&lt;/span>release() { compiler_barrier(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OrderAccess&lt;span style="color:#f92672">::&lt;/span>fence() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// always use locked addl since mfence is sometimes expensive
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#ifdef AMD64
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> __asm__ &lt;span style="color:#66d9ef">volatile&lt;/span> (&lt;span style="color:#e6db74">&amp;#34;lock; addl $0,0(%%rsp)&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;cc&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;memory&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> __asm__ &lt;span style="color:#66d9ef">volatile&lt;/span> (&lt;span style="color:#e6db74">&amp;#34;lock; addl $0,0(%%esp)&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;cc&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;memory&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> compiler_barrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="lock前缀指令的作用">lock前缀指令的作用&lt;/h3>
&lt;ol>
&lt;li>确保后续指令执行的原子性。在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销。&lt;/li>
&lt;li>LOCK前缀指令具有类似于内存屏障的功能，禁止该指令与前面和后面的读写指令重排序。&lt;/li>
&lt;li>LOCK前缀指令会等待它之前所有的指令完成、并且所有缓冲的写操作写回内存(也就是将store buffer中的内容写入内存)之后才开始执行，并且根据缓存一致性协议，刷新store buffer的操作会导致其他cache中的副本失效。&lt;/li>
&lt;/ol>
&lt;h3 id="汇编层面volatile的实现">汇编层面volatile的实现&lt;/h3>
&lt;p>添加下面的jvm参数查看之前可见性Demo的汇编指令&lt;/p>
&lt;p>&lt;code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://img.hinathan.online/2025/07/343842034.png" alt="343842034">&lt;/p>
&lt;p>验证了可见性使用了&lt;strong>lock前缀指令&lt;/strong>&lt;/p>
&lt;h3 id="从硬件层面分析lock前缀指令">从硬件层面分析Lock前缀指令&lt;/h3>
&lt;p>《64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf》中有如下描述：&lt;/p>
&lt;blockquote>
&lt;p>The 32-bit IA-32 processors support locked atomic operations on locations in system memory. These operations are typically used to manage shared data structures (such as semaphores, segment descriptors, system segments, or page tables) in which two or more processors may try simultaneously to modify the same field or flag. The processor uses three interdependent mechanisms for carrying out locked atomic operations:&lt;/p>
&lt;p>• Guaranteed atomic operations&lt;/p>
&lt;p>• Bus locking, using the LOCK# signal and the LOCK instruction prefix&lt;/p>
&lt;p>• Cache coherency protocols that ensure that atomic operations can be carried out on cached data structures (cache lock); this mechanism is present in the Pentium 4, Intel Xeon, and P6 family processors&lt;/p>
&lt;/blockquote>
&lt;p>32位的IA-32处理器支持对系统内存中的位置进行锁定的原子操作。这些操作通常用于管理共享的数据结构(如信号量、段描述符、系统段或页表)，在这些结构中，两个或多个处理器可能同时试图修改相同的字段或标志。&lt;/p>
&lt;p>处理器使用三种相互依赖的机制来执行锁定的原子操作:&lt;/p>
&lt;ul>
&lt;li>有保证的原子操作&lt;/li>
&lt;li>总线锁定，使用LOCK#信号和LOCK指令前缀&lt;/li>
&lt;li>缓存一致性协议，确保原子操作可以在缓存的数据结构上执行(缓存锁);这种机制出现在Pentium 4、Intel Xeon和P6系列处理器中&lt;/li>
&lt;/ul></description></item><item><title>Java并发编程（二）JMM&amp;并发三大特性-原子性</title><link>https://www.hinathan.online/blog/02-jmm_and_atomicity/</link><pubDate>Fri, 10 Jan 2020 21:20:16 +0800</pubDate><guid>https://www.hinathan.online/blog/02-jmm_and_atomicity/</guid><description>&lt;h2 id="从三个角度分析">从三个角度分析&lt;/h2>
&lt;ol>
&lt;li>Java层面&lt;/li>
&lt;li>Jvm层面&lt;/li>
&lt;li>硬件层面&lt;/li>
&lt;/ol>
&lt;p>这部分理解并发的三大特性，JMM工作内存和主内存关系，知道多线程之间如何通信的，掌握&lt;code>volatile&lt;/code>能保证可见性和有序性，&lt;code>CAS&lt;/code>就可以了，后续JVM层面和硬件层面的分析（可以看完Java锁机制，常用的并发工具类，并发容器之后再来看JMM这块。）&lt;/p>
&lt;h2 id="并发三大特性">并发三大特性&lt;/h2>
&lt;p>并发编程Bug的源头：可见性、原子性和有序性问题&lt;/p>
&lt;h3 id="原子性">原子性&lt;/h3>
&lt;p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。在 Java 中，&lt;u>对基本数据类型的变量的读取和赋值操作是原子性操作（64位处理器）。&lt;/u>不采取任何的原子性保障措施的自增操作并不是原子性的。&lt;/p>
&lt;h4 id="如何保证原子性">如何保证原子性&lt;/h4>
&lt;ul>
&lt;li>通过&lt;code>synchronized&lt;/code>关键字保证原子性。&lt;/li>
&lt;li>通过&lt;code>Lock&lt;/code>保证原子性。&lt;/li>
&lt;li>通过&lt;code>CAS&lt;/code>保证原子性。&lt;/li>
&lt;/ul>
&lt;h4 id="在-32-位的机器上对-long-型变量进行加减操作是否存在并发隐患">在 32 位的机器上对 long 型变量进行加减操作是否存在并发隐患？&lt;/h4>
&lt;p>是的！在 32 位机器上对 &lt;strong>long 型变量&lt;/strong> 进行简单的加减操作（例如 &lt;code>count++&lt;/code> 或 &lt;code>count += 1&lt;/code>）存在明显的并发隐患。&lt;/p>
&lt;blockquote>
&lt;p>For the purposes of the Java programming language memory model, a single write to a non-volatile &lt;code>long&lt;/code> or &lt;code>double&lt;/code> value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.&lt;/p>
&lt;p>Writes and reads of volatile &lt;code>long&lt;/code> and &lt;code>double&lt;/code> values are always atomic.&lt;/p>
&lt;p>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.&lt;/p>
&lt;p>Some implementations may find it convenient to divide a single write action on a 64-bit &lt;code>long&lt;/code> or &lt;code>double&lt;/code> value into two write actions on adjacent 32-bit values. For efficiency&amp;rsquo;s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to &lt;code>long&lt;/code> and &lt;code>double&lt;/code> values atomically or in two parts.&lt;/p>
&lt;p>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as &lt;code>volatile&lt;/code> or synchronize their programs correctly to avoid possible complications.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>对于 Java 编程语言的内存模型而言，对一个非 volatile 的 long 或 double 值的单次写入会被视为两次单独的写入操作：分别对该值的高32位和低32位进行写入。这可能导致某个线程看到的64位数值中，前32位来自某次写操作，而后32位却来自另一次写操作。&lt;/p>
&lt;p>对 volatile 修饰的 long 和 double 值的读写操作始终是原子性的。&lt;/p>
&lt;p>对引用类型（references）的读写操作始终是原子性的，无论它们具体是以32位还是64位的方式实现。&lt;/p>
&lt;p>某些 Java 虚拟机的实现出于便利，可能会将对64位的 long 或 double 值的一次写操作拆分成对两个连续32位数值的两次写操作。为了效率起见，这种行为是依赖于具体实现的；Java 虚拟机的实现可以自由选择将对 long 和 double 的写操作作为原子操作进行，或分为两部分进行。&lt;/p>
&lt;p>建议 Java 虚拟机的实现尽量避免对64位数值的写入进行拆分。同时建议程序员在声明共享的64位变量时使用 volatile 修饰，或正确地对程序进行同步，以避免潜在的问题。&lt;/p>
&lt;/blockquote>
&lt;h2 id="java内存模型jmm">Java内存模型（JMM）&lt;/h2>
&lt;h3 id="jmm定义">JMM定义&lt;/h3>
&lt;p>Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。&lt;/p>
&lt;p>JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程&lt;code>如何&lt;/code>和&lt;code>何时&lt;/code>可以看到由其他线程修改过后的共享变量的值，以及在必须时&lt;code>如何同步&lt;/code>的访问共享变量。JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，&lt;u>JMM是围绕原子性、有序性、可见性展开的&lt;/u>。&lt;/p>
&lt;p>&lt;img src="https://img.hinathan.online/2025/07/28523.png" alt="">&lt;/p>
&lt;h3 id="jmm与硬件内存架构的关系">JMM与硬件内存架构的关系&lt;/h3>
&lt;p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：&lt;/p>
&lt;p>&lt;img src="https://img.hinathan.online/2025/07/42981.png" alt="">&lt;/p>
&lt;h3 id="内存交互操作">内存交互操作&lt;/h3>
&lt;p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，&lt;code>Java内存模型定义了以下八种操作&lt;/code>来完成：&lt;/p>
&lt;ul>
&lt;li>&lt;code>lock&lt;/code>：锁定，作用于主内存的变量，把一个变量标识为一条线程独占状态。&lt;/li>
&lt;li>&lt;code>read&lt;/code>：读取，作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用&lt;/li>
&lt;li>&lt;code>load&lt;/code>：载入，作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。&lt;/li>
&lt;li>&lt;code>use&lt;/code>：使用，作用于工作内存的变量，把工作内存中的一个变量值传递给&lt;code>执行引擎&lt;/code>，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。&lt;/li>
&lt;li>&lt;code>assign&lt;/code>：赋值，作用于工作内存的变量，它把一个从&lt;code>执行引擎&lt;/code>接收到的值赋值给&lt;code>工作内存&lt;/code>的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。&lt;/li>
&lt;li>&lt;code>store&lt;/code>：存储，作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。&lt;/li>
&lt;li>&lt;code>write&lt;/code>：写入，作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。&lt;/li>
&lt;li>&lt;code>unlock&lt;/code>：解锁，作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://img.hinathan.online/2025/07/27711.png" alt="">&lt;/p>
&lt;ul>
&lt;li>read和load成对出现&lt;/li>
&lt;li>store和write成对出现&lt;/li>
&lt;/ul>
&lt;p>其实很好理解，下面是具体的规则↓↓↓&lt;/p>
&lt;h4 id="内存交互操作规则">内存交互操作规则&lt;/h4>
&lt;p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：&lt;/p>
&lt;ul>
&lt;li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。&lt;/li>
&lt;li>不允许read和load、store和write操作之一单独出现&lt;/li>
&lt;li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。&lt;/li>
&lt;li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。&lt;/li>
&lt;li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。&lt;/li>
&lt;li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现&lt;/li>
&lt;li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值&lt;/li>
&lt;li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。&lt;/li>
&lt;li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。&lt;/li>
&lt;/ul></description></item><item><title>Java并发编程（一）线程基础、线程之间的共享和协作</title><link>https://www.hinathan.online/blog/01-process_and_thread/</link><pubDate>Fri, 03 Jan 2020 20:28:34 +0800</pubDate><guid>https://www.hinathan.online/blog/01-process_and_thread/</guid><description>&lt;h2 id="什么是进程和线程">什么是进程和线程&lt;/h2>
&lt;h3 id="进程是程序运行资源分配的最小单位">进程是程序运行资源分配的最小单位&lt;/h3>
&lt;p>进程是操作系统进行资源分配的最小单位，其中资源包括:CPU、内存空间、磁盘 IO 等，同一进程中的多条线程共享该进程中的全部系统资源，而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，&lt;strong>进程是系统进行资源分配和调度的一个独立单位。&lt;/strong>&lt;/p>
&lt;p>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身，用户进程就是所有由你启动的进程。&lt;/p>
&lt;p>&lt;strong>线程是 CPU调度的最小单位，必须依赖于进程而存在！&lt;/strong>&lt;/p>
&lt;p>线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。&lt;/p>
&lt;h3 id="线程无处不在">线程无处不在&lt;/h3>
&lt;p>任何一个程序都必须要创建线程，特别是 Java 不管任何程序都必须启动一个&lt;/p>
&lt;p>main 函数的主线程；Java Web 开发里面的定时任务、定时器、JSP 和 Servlet、异步消息处理机制，远程访问接口RM 等，任何一个监听事件,，onclick 的触发事件等都离不开线程和并发的知识。&lt;/p>
&lt;h3 id="cpu核心数和线程数的关系">CPU核心数和线程数的关系&lt;/h3>
&lt;p>多核心：也指单芯片多处理器( &lt;code>Chip Multiprocessors&lt;/code>，简称 &lt;code>CMP&lt;/code>)，CMP 是由美国斯坦福大学提出的，其思想是将大规模并行处理器中的 SMP（对称多处理器）集成到同一芯片内，各个处理器并行执行不同的进程。这种依靠多个 CPU 同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理&lt;/p>
&lt;p>多线程: &lt;code>Simultaneous Multithreading&lt;/code>，简称 &lt;code>SMT&lt;/code>。让同一个处理器上的多个线程同步执行并共享处理器的执行资源。&lt;/p>
&lt;p>核心数、线程数:目前主流 CPU 都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是 1:1 对应关系,也就是说四核 CPU 一般拥有四个线程。但 Intel 引入超线程技术后,使核心数与线程数形成 1:2 的关系&lt;/p>
&lt;p style="text-align: center;">
&lt;img src="https://img.hinathan.online/2025/07/image-20250329071857402.png" alt="image-20250329071857402" style="zoom:50%;" />
&lt;/p>
&lt;h3 id="cpu时间片轮转机制">CPU时间片轮转机制&lt;/h3>
&lt;p>我们平时在开发的时候，感觉并没有受 cpu 核心数的限制，想启动线程就启动线程，哪怕是在单核 CPU 上，为什么？这是因为操作系统提供了一种 CPU 时间片轮转机制。&lt;/p>
&lt;p>时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法，又称 RR调度（&lt;code>Round Robin&lt;/code>）。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。百度百科对 CPU 时间片轮转机制原理解释如下：
&lt;a href="..%2F..%2F..%2F..%2FIdeaProjects%2FBlog%2Fout%2Fproduction%2FBlog%2FWorker.class">Worker.class&lt;/a>
如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换。调度程序所要做的就是维护一张就绪&lt;code>进程列表&lt;/code>，当进程用完它的时间片后，它被移到队列的末尾。&lt;/p>
&lt;p>时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的，包括保存和装入寄存器值及内存映像，更新各种表格和队列等。假如进程切换( &lt;code>processwitch&lt;/code>)，有时称为上下文切换(&lt;code> context switch&lt;/code>)，需要 5ms，再假设时间片设为 20ms，则在做完 20ms 有用的工作之后，CPU 将花费 5ms 来进行进程切换。CPU 时间的 20%被浪费在了管理开销上了。&lt;/p>
&lt;p>为了提高 CPU 效率，我们可以将时间片设为 5000ms。这时浪费的时间只有1%。但考虑到在一个分时系统中，如果有 10 个交互用户几乎同时按下回车键,，将发生什么情况？假设所有其他进程都用足它们的时间片的话，最后一个不幸的进程不得不等待 5s 才获得运行机会。多数用户无法忍受一条简短命令要 5 s才能做出响应，同样的问题在一台支持多道程序的个人计算机上也会发生。&lt;/p>
&lt;p>结论可以归结如下：时间片设得太短会导致过多的进程切换，降低了CPU 效率；而设得太长又可能引起对短的交互请求的响应变差。将时间片设为 100ms 通常是一个比较合理的折衷。&lt;/p>
&lt;p>在CPU 死机的情况下，其实大家不难发现当运行一个程序的时候把 CPU 给弄到了100%再不重启电脑的情况下，其实我们还是有机会把它Kill掉的，我想也正是因为这种机制的缘故。&lt;/p>
&lt;h3 id="并行和并发">并行和并发&lt;/h3>
&lt;p>我们举个例子，如果有条高速公路 A 上面并排有 8 条车道，那么最大的&lt;strong>并行&lt;/strong>车辆就是 8 辆。此条高速公路 A 同时并排行走的车辆小于等于 8 辆的时候，车辆就可以并行运行。CPU 也是这个原理，一个 CPU 相当于一个高速公路 A，核心数或者线程数就相当于并排可以通行的车道；而多个CPU 就相当于并排有多条高速公路，而每个高速公路并排有多个车道。&lt;/p>
&lt;p>当谈论&lt;strong>并发&lt;/strong>的时候一定要加个单位时间，也就是说单位时间内并发量是多少? 离开了单位时间其实是没有意义的。&lt;/p>
&lt;p>俗话说，一心不能二用，这对计算机也一样，原则上一个 CPU 只能分配给一个进程，以便运行这个进程。我们通常使用的计算机中只有一个 CPU，也就是说只有一颗心，要让它一心多用同时运行多个进程，就必须使用并发技术！实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”。&lt;/p>
&lt;p>综合来说：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>并发：指应用能够交替执行不同的任务，比如单CPU 核心下执行多线程并非是同时执行多个任务，如果你开两个线程执行，就是在你几乎不可能察觉到的速度不断去切换这两个任务，已达到&amp;quot;同时执行效果&amp;quot;，其实并不是的，只是计算机的速度太快，我们无法察觉到而已。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>并行：指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话，这两件事情可以同时执行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>两者区别:一个是交替执行，一个是同时执行。&lt;/p>
&lt;p>&lt;img src="https://img.hinathan.online/2025/07/image-20250329074107107.png" alt="image-20250329074107107">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="高并发编程的意义好处和注意事项">高并发编程的意义、好处和注意事项&lt;/h3>
&lt;p>由于多核多线程的 CPU 的诞生，多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。&lt;/p>
&lt;ul>
&lt;li>充分利用 CPU 的资源&lt;/li>
&lt;/ul>
&lt;p>从上面的CPU 的介绍，可以看的出来，现在市面上没有CPU 的内核不使用多线程并发机制的，特别是服务器还不止一个CPU，如果还是使用单线程的技术做思路,，明显就 out 了。因为程序的基本调度单元是线程，并且一个线程也只能在一个 CPU 的一个核的一个线程跑，如果你是个i3 的CPU 的话,最差也是双核心 4 线程的运算能力。如果是一个线程的程序的话，那是要浪费 3/4 的CPU 性能。如果设计一个多线程的程序的话，那它就可以同时在多个CPU 的多个核的多个线程上跑，可以充分地利用 CPU，减少 CPU 的空闲时间，发挥它的运算能力，提高并发量。&lt;/p>
&lt;p>&lt;u>&lt;strong>就像我们平时坐地铁一样，很多人坐长线地铁的时候都在认真看书，而不是为了坐地铁而坐地铁，到家了再去看书，这样你的时间就相当于有了两倍。这就是为什么有些人时间很充裕，而有些人老是说没时间的一个原因，工作也是这样，有的时候可以并发地去做几件事情，充分利用我们的时间，CPU 也是一样，也要充分利用。&lt;/strong>&lt;/u>&lt;/p>
&lt;ul>
&lt;li>加快响应用户的时间&lt;/li>
&lt;/ul>
&lt;p>比如我们经常用的迅雷下载，都喜欢多开几个线程去下载，谁都不愿意用一个线程去下载，为什么呢？答案很简单，就是多个线程下载快啊。我们在做程序开发的时候更应该如此，特别是我们做互联网项目，网页的响应时间若提升 1s，如果流量大的话，就能增加不少转换量。做过高性能 web 前端调优的都知道，要将静态资源地址用两三个子域名去加载，为什么？因为每多一个子域名，浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源，提升网站的响应速度。多线程、高并发真的是无处不在！&lt;/p>
&lt;ul>
&lt;li>可以使你的代码模块化，异步化，简单化&lt;/li>
&lt;/ul>
&lt;p>例如我们实现电商系统，下订单和给用户发送短信、邮件就可以进行拆分， 将给用户发送短信、邮件这两个步骤独立为单独的模块，并交给其他线程去执行。这样既增加了异步的操作，提升了系统性能，又使程序模块化，清晰化和简单化。&lt;/p>
&lt;p>多线程应用开发的好处还有很多，大家在日后的代码编写过程中可以慢慢体会它的魅力。&lt;/p>
&lt;h3 id="多线程程序需要注意事项">多线程程序需要注意事项&lt;/h3>
&lt;ul>
&lt;li>线程之间的安全性&lt;/li>
&lt;/ul>
&lt;p>从前面的章节中我们都知道，在同一个进程里面的多线程是资源共享的，也就是都可以访问同一个内存地址当中的一个变量。例如：若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的。若有多 个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全！&lt;/p>
&lt;ul>
&lt;li>线程之间的死锁&lt;/li>
&lt;/ul>
&lt;p>为了解决线程之间的安全性引入了 Java 的锁机制，而一不小心就会产生 Java 线程死锁的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。假设有两个线程，分别代表两个饥饿的人，他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁：共享刀和共享叉的锁。&lt;/p>
&lt;p>假如线程 A 获得了刀，而线程 B 获得了叉。线程 A 就会进入阻塞状态来等待获得叉，而线程 B 则阻塞来等待线程 A 所拥有的刀。这只是人为设计的例子，但尽管在运行时很难探测到这类情况却时常发生。&lt;/p>
&lt;ul>
&lt;li>线程太多了会将服务器资源耗尽形成死机宕机&lt;/li>
&lt;/ul>
&lt;p>线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及 CPU的“过渡切换”，造成系统的死机，那么我们该如何解决这类问题呢？&lt;/p>
&lt;p>某些系统资源是有限的，如文件描述符。多线程程序可能耗尽资源，因为每个线程都可能希望有一个这样的资源。如果线程数相当大，或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接，它就从池中取出一个，使用以后再将它返回池中。资源池也称为资源库。&lt;/p>
&lt;p>多线程应用开发的注意事项很多，希望大家在日后的工作中可以慢慢体会它的危险所在。&lt;/p>
&lt;h2 id="认识java-里的线程">认识Java 里的线程&lt;/h2>
&lt;h3 id="java程序天生就是多线程的">Java程序天生就是多线程的&lt;/h3>
&lt;p>一个 Java 程序从 &lt;code>main()&lt;/code>方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上 Java 程序天生就是多线程程序，因为执行 &lt;code>main()&lt;/code> 方法的是一个名称为 &lt;code>main &lt;/code>的线程。&lt;/p>
&lt;h3 id="线程的启动与中止">线程的启动与中止&lt;/h3>
&lt;h4 id="启动">启动&lt;/h4>
&lt;p>启动线程的方式有：&lt;/p>
&lt;ol>
&lt;li>X extends Thread;，然后 X.start&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Thread &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Main main &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Main&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> main&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>X implements Runnable；然后交给 Thread 运行&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread thread &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> Runnable&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thread 和 Runnable 的区别&lt;/p>
&lt;p>Thread 才是 Java 里对线程的唯一抽象，Runnable 只是对任务（业务逻辑） 的抽象。Thread 可以接受任意一个 Runnable 的实例并执行。&lt;/p>
&lt;h4 id="中止">中止&lt;/h4>
&lt;p>线程自然终止，要么是 run 执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。&lt;/p>
&lt;h5 id="stop">stop&lt;/h5>
&lt;p>暂停、恢复和停止操作对应在线程 Thread 的 API 就是 &lt;code>suspend()&lt;/code>、&lt;code>resume()&lt;/code>和 &lt;code>stop()&lt;/code>。但是这些 API 是过期的，也就是不建议使用的。不建议使用的原因主要有：以 suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方 法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为 suspend()、resume()和 stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。&lt;/p>
&lt;h4 id="中断">中断&lt;/h4>
&lt;p>安全的中止则是其他线程通过调用某个线程A 的&lt;code> interrupt()&lt;/code>方法对其进行中断操作，中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程 A 会立即停止自己的工作，同样的 A 线程完全可以不理会这种中断请求。线程通过检查自身的中断标志位是否被置为 true 来进行响应。&lt;/p>
&lt;p>线程通过方法 &lt;code>isInterrupted()&lt;/code>来进行判断是否被中断，也可以调用静态方法&lt;/p>
&lt;p>&lt;code>Thread.interrupted()&lt;/code>来进行判断当前线程是否被中断，不过&lt;code> Thread.interrupted()&lt;/code>会同时将中断标识位改写为 false。&lt;/p>
&lt;p>如果一个线程处于了阻塞状态（如线程调用了 thread.sleep、thread.join、thread.wait 等），则在线程在检查中断标示时如果发现中断标示为 true，则会在这些阻塞方法调用处抛出 &lt;code>InterruptedException&lt;/code> 异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为 false。&lt;/p>
&lt;p>不建议自定义一个取消标志位来中止线程的运行。因为 run 方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为：&lt;/p>
&lt;ol>
&lt;li>一般的阻塞方法，如 sleep 等本身就支持中断的检查。&lt;/li>
&lt;li>检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>注意：处于死锁状态的线程无法被中断&lt;/strong>&lt;/p>
&lt;h3 id="对java里的线程再多一点点认识">对Java里的线程再多一点点认识&lt;/h3>
&lt;h4 id="深入理解run和start">深入理解run()和start()&lt;/h4>
&lt;p>Thread 类是Java 里对线程概念的抽象，可以这样理解：我们通过new Thread() 其实只是 new 出一个 Thread 的实例，还没有操作系统中真正的线程挂起钩来。只有执行了 start()方法后，才实现了真正意义上的启动线程。&lt;/p>
&lt;p>start()方法让一个线程进入就绪队列等待分配 cpu，分到 cpu 后才调用实现的 run()方法，start()方法不能重复调用，如果重复调用会抛出异常。而 run 方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。&lt;/p>
&lt;h4 id="其他的线程相关方法">其他的线程相关方法&lt;/h4>
&lt;p>&lt;code>yield()&lt;/code>方法：使当前线程让出 CPU 占有权，但让出的时间是不可设定的。也不会释放锁资源。&lt;/p>
&lt;p>注意：并不是每个线程都需要这个锁的，而且执行 &lt;code>yield( )&lt;/code>的线程不一定就会持有锁，我们完全可以在释放锁后再调用 yield 方法。所有执行 yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。&lt;/p>
&lt;h4 id="join方法">join方法&lt;/h4>
&lt;p>把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程 B 中调用了线程 A 的 Join()方法，直到线程 A 执行完毕后，才会继续执行线程 B。&lt;/p>
&lt;h4 id="线程的优先级">线程的优先级&lt;/h4>
&lt;p>在 Java 线程中，通过一个整型成员变量&lt;code> priority&lt;/code> 来控制优先级，优先级的范围从 1~10，在线程构建的时候可以通过 &lt;code>setPriority(int)&lt;/code>方法来修改优先级，默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。&lt;/p>
&lt;p>设置线程优先级时，针对频繁阻塞（休眠或者 I/O 操作）的线程需要设置较高优先级，而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的 JVM 以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。&lt;/p>
&lt;h2 id="线程的调度">线程的调度&lt;/h2>
&lt;p>线程调度是指系统为线程分配 CPU 使用权的过程，主要调度方式有两种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>协同式线程调度(Cooperative Threads-Scheduling)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抢占式线程调度(Preemptive Threads-Scheduling)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>使用协同式线程调度的多线程系统，线程执行的时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。使用协同式线程调度的最大好处是实现简单，由于线程要把自己的事情做完后才会通知系统进行线程切换，所以没有线程同步的问题，但是坏处也很明显，如果一个线程出了问题，则程序就会一直阻塞。&lt;/p>
&lt;p>使用抢占式线程调度的多线程系统，每个线程执行的时间以及是否切换都由系统决定。在这种情况下，线程的执行时间不可控，所以不会有「一个线程导致整个进程阻塞」的问题出现。&lt;/p>
&lt;p>在 Java 中，Thread.yield()可以让出 CPU 执行时间，但是对于获取，线程本身是没有办法的。对于获取 CPU 执行时间，线程唯一可以使用的手段是设置线程优先级，Java 设置了 10 个级别的程序优先级，当两个线程同时处于 Ready 状态时，优先级越高的线程越容易被系统选择执行。&lt;/p>
&lt;p>Java 中的线程优先级是通过映射到操作系统的原生线程上实现的，所以线程的调度最终取决于操作系统，操作系统中线程的优先级有时并不能和 Java 中的一一对应，&lt;u>&lt;strong>所以 Java 优先级并不是特别靠谱&lt;/strong>&lt;/u>。&lt;/p>
&lt;p>所以在面试中如果遇到相关的问题，可以这样回答：Java 中的线程是通过映射到操作系统的原生线程上实现的，所以线程的调度最终取决于操作系统，而操作系统级别，OS 是以抢占式调度线程，我们可以认为线程是抢占式的。Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。而且操作系统中线程的优先级有时并不能和 Java 中的一一对应，所以 Java 优先级并不是特别靠谱。但是在 Java 中，因为 Java 没有提供安全的抢占式方法来停止线程，要安全的停止线程只能以协作式的方式。&lt;/p>
&lt;h2 id="守护线程">守护线程&lt;/h2>
&lt;p>Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在&lt;strong>非&lt;/strong> Daemon 线程的时候，Java 虚拟机将会退出。可以通过调用 &lt;code>Thread.setDaemon(true)&lt;/code>将线程设置为 Daemon 线程。&lt;/p>
&lt;p>我们一般用不上，比如垃圾回收线程就是 Daemon 线程。&lt;/p>
&lt;p>Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行。在构建 Daemon 线程时，不能依靠 finally 块中的内容来确保执行关闭或清理资源的逻辑。&lt;/p>
&lt;h2 id="线程间的共享和协作">线程间的共享和协作&lt;/h2>
&lt;h3 id="线程间的共享">线程间的共享&lt;/h3>
&lt;h4 id="synchronized内置锁">synchronized内置锁&lt;/h4>
&lt;p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行， 那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作， 包括数据之间的共享，协同处理事情。这将会带来巨大的价值。&lt;/p>
&lt;p>Java 支持多个线程同时访问一个对象或者对象的成员变量，关键字&lt;code>synchronized&lt;/code> 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。&lt;/p>
&lt;p>对象锁和类锁：&lt;/p>
&lt;p>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的 class 对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个 class 对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。&lt;/p>
&lt;p>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的 class 对象。类锁和对象锁之间也是互不干扰的。&lt;/p>
&lt;p>&lt;strong>错误的加锁和原因分析&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Worker&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Runnable &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Integer i&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Worker&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Integer i&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread thread &lt;span style="color:#f92672">=&lt;/span> Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sleep&lt;/span>&lt;span style="color:#f92672">(&lt;/span>3000&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">(&lt;/span>InterruptedException e&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">printStackTrace&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原因：虽然我们对 i 进行了加锁，但是&lt;/p>
&lt;p>但是当我们反编译这个类的 class 文件后，可以看到 i++实际是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">valueOf&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">intValue&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Integer &lt;span style="color:#a6e22e">valueOf&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String s&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> radix&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> NumberFormatException &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">valueOf&lt;/span>&lt;span style="color:#f92672">(&lt;/span>parseInt&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">,&lt;/span>radix&lt;span style="color:#f92672">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本质上是返回了一个新的 &lt;code>Integer&lt;/code> 对象。也就是每个线程实际加锁的是不同的 &lt;code>Integer&lt;/code> 对象。&lt;/p>
&lt;h4 id="volatile最轻量的同步机制">volatile最轻量的同步机制&lt;/h4>
&lt;p>&lt;code>volatile&lt;/code>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。参见代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">VolatileCase&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> ready &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>ready&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;循环ready:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> ready&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sleep&lt;/span>&lt;span style="color:#f92672">(&lt;/span>1000&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">(&lt;/span>InterruptedException e&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException&lt;span style="color:#f92672">(&lt;/span>e&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> Runnable&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ready &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}).&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不加 volatile 时，子线程无法感知主线程修改了 ready 的值，从而不会退出循环， 而加了 volatile 后，子线程可以感知主线程修改了 ready 的值，迅速退出循环。&lt;/p>
&lt;p>但是 volatile 不能保证数据在多个线程下同时写时的线程安全&lt;/p>
&lt;p>volatile 最适用的场景：一个线程写，多个线程读。&lt;/p>
&lt;h2 id="threadlocal">ThreadLocal&lt;/h2>
&lt;h3 id="与synchonized-的比较">与Synchonized 的比较&lt;/h3>
&lt;p>ThreadLocal 和 Synchonized 都用于解决多线程并发访问。可是 ThreadLocal 与 synchronized 有本质的差别。synchronized 是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程访问。而 ThreadLocal 为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。&lt;/p>
&lt;p>Spring 的事务就借助了 ThreadLocal 类。Spring 会从数据库连接池中获得一个connection，然会把 connection 放进 ThreadLocal 中，也就和线程绑定了，事务需要提交或者回滚，只要从 ThreadLocal 中拿到 connection 进行操作。为何 Spring 的事务要借助 ThreadLocal 类？&lt;/p>
&lt;p>以 JDBC 为例，正常的事务代码可能如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>dbc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DataBaseConnection&lt;span style="color:#f92672">();&lt;/span>&lt;span style="color:#75715e">//第 1 行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Connection con &lt;span style="color:#f92672">=&lt;/span> dbc&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getConnection&lt;/span>&lt;span style="color:#f92672">();&lt;/span>&lt;span style="color:#75715e">//第 2 行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>con&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setAutoCommit&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">);&lt;/span>&lt;span style="color:#75715e">//第 3 行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>con&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">executeUpdate&lt;/span>&lt;span style="color:#f92672">(...);&lt;/span>&lt;span style="color:#75715e">//第 4 行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>con&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">executeUpdate&lt;/span>&lt;span style="color:#f92672">(...);&lt;/span>&lt;span style="color:#75715e">//第 5 行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>con&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">executeUpdate&lt;/span>&lt;span style="color:#f92672">(...);&lt;/span>&lt;span style="color:#75715e">//第 6 行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>con&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">commit&lt;/span>&lt;span style="color:#f92672">();&lt;/span>&lt;span style="color:#75715e">////第 7 行
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述代码，可以分成三个部分:&lt;/p>
&lt;p>事务准备阶段：第 1～3 行业务处理阶段：第 4～6 行事务提交阶段：第 7 行可以很明显的看到，不管我们开启事务还是执行具体的 sql 都需要一个具体的数据库连接。&lt;/p>
&lt;p>现在我们开发应用一般都采用三层结构，如果我们控制事务的代码都放在DAO(DataAccessObject)对象中，在 DAO 对象的每个方法当中去打开事务和关闭事务，当 Service 对象在调用 DAO 时，如果只调用一个 DAO，那我们这样实现则效果不错，但往往我们的 Service 会调用一系列的 DAO 对数据库进行多次操作， 那么，这个时候我们就无法控制事务的边界了，因为实际应用当中，我们的 Service 调用的 DAO 的个数是不确定的，可根据需求而变化，而且还可能出现 Service 调用 Service 的情况。&lt;/p>
&lt;p>如果不使用 ThreadLocal，代码大概就会是这个样子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">serviceMethod&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Connection connection &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connection&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getConnection&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connection&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setAutoCommit&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dao1 dao1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Dao1&lt;span style="color:#f92672">(&lt;/span>connection&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dao1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">doSomething&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dao2 dao2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Dao2&lt;span style="color:#f92672">(&lt;/span>connection&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dao2&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">doSomething&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dao3 dao3 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Dao3&lt;span style="color:#f92672">(&lt;/span>connection&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dao3&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">doSomething&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connection&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">commit&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Exception e&lt;span style="color:#f92672">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">printStackTrace&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Class Dao1&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Connection connection &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Dao1&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Connection connection&lt;span style="color:#f92672">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">connection&lt;/span> &lt;span style="color:#f92672">=&lt;/span> connection&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>&lt;span style="color:#f92672">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是需要注意一个问题，如何让三个 DAO 使用同一个数据源连接呢？我们就必须为每个 DAO 传递同一个数据库连接，要么就是在 DAO 实例化的时候作为构造方法的参数传递，要么在每个 DAO 的实例方法中作为方法的参数传递。这两种方式无疑对我们的 Spring 框架或者开发人员来说都不合适。为了让这个数据库连接可以跨阶段传递，又不显示的进行参数传递，就必须使用别的办法。&lt;/p>
&lt;p>Web 容器中，每个完整的请求周期会由一个线程来处理。因此，如果我们能将一些参数绑定到线程的话，就可以实现在软件架构中跨层次的参数共享（是隐式的共享）。而 Java 中恰好提供了绑定的方法使用 ThreadLocal。&lt;/p>
&lt;p>结合使用 Spring 里的 IOC 和 AOP，就可以很好的解决这一点。&lt;/p>
&lt;p>只要将一个数据库连接放入 ThreadLocal 中，当前线程执行时只要有使用数据库连接的地方就从 ThreadLocal 获得就行了。&lt;/p>
&lt;h3 id="threadlocal的使用">ThreadLocal的使用&lt;/h3>
&lt;p>ThreadLocal 类接口很简单，只有 4 个方法，我们先来了解一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>T value&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set&lt;span style="color:#f92672">(&lt;/span>Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> value&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>TRACE_VTHREAD_LOCALS&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dumpStackIfVirtualThread&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置当前线程的线程局部变量的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> T &lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get&lt;span style="color:#f92672">(&lt;/span>Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法返回当前线程所对应的线程局部变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">remove&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remove&lt;span style="color:#f92672">(&lt;/span>Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是 jdk新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protected&lt;/span> T &lt;span style="color:#a6e22e">initialValue&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回该线程局部变量的初始值，该方法是一个 protected 的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第 1 次调用 get() 或 set(Object)时才执行，并且仅执行 1 次。ThreadLocal 中的缺省实现直接返回一个 null。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ThreadLocal RESOURCE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ThreadLocal&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RESOURCE 代表一个能够存放String 类型的ThreadLocal 对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是 线程安全的。&lt;/p>
&lt;p>&lt;em>实现解析&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ThreadLocalMap &lt;span style="color:#a6e22e">getMap&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Thread t&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> t&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">threadLocals&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> T &lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get&lt;span style="color:#f92672">(&lt;/span>Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> T &lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Thread t&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadLocalMap map &lt;span style="color:#f92672">=&lt;/span> getMap&lt;span style="color:#f92672">(&lt;/span>t&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>map &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadLocalMap&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">Entry&lt;/span> e &lt;span style="color:#f92672">=&lt;/span> map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getEntry&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>e &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;unchecked&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>T&lt;span style="color:#f92672">)&lt;/span> e&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> setInitialValue&lt;span style="color:#f92672">(&lt;/span>t&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://img.hinathan.online/2025/07/687474703a2f2f75706c6f61642d.jpg" alt="threadLocal引用示意图">&lt;/p>
&lt;p>上面先取到当前线程，然后调用 getMap 方法获取对应的 ThreadLocalMap，&lt;/p>
&lt;p>ThreadLocalMap 是 ThreadLocal 的静态内部类，然后 Thread 类中有一个这样类型成员，所以 getMap 是直接返回 Thread 的成员。&lt;/p>
&lt;p>看下 ThreadLocal 的内部类 ThreadLocalMap 源码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadLocalMap&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Entry&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> WeakReference&lt;span style="color:#f92672">&amp;lt;&lt;/span>ThreadLocal&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/** The value associated with this ThreadLocal. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object value&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 类似于map的key、value结构，key就是ThreadLocal，value就是需要隔离访问的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Entry&lt;span style="color:#f92672">(&lt;/span>ThreadLocal&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> k&lt;span style="color:#f92672">,&lt;/span> Object v&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>k&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">=&lt;/span> v&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 用数组保存Entry 因为可能有多个变量需要线程隔离访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> Entry&lt;span style="color:#f92672">[]&lt;/span> table&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到有个 Entry 内部静态类，它继承了 WeakReference，总之它记录了两个信息，一个是 ThreadLocal类型，一个是 Object 类型的值。getEntry 方法则是获取某个 ThreadLocal 对应的值，set 方法就是更新或赋值相应的 ThreadLocal对应的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> Entry &lt;span style="color:#a6e22e">getEntry&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ThreadLocal&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> key&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> key&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">threadLocalHashCode&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#f92672">(&lt;/span>table&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry e &lt;span style="color:#f92672">=&lt;/span> table&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>e &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> e&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">refersTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>key&lt;span style="color:#f92672">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> e&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> getEntryAfterMiss&lt;span style="color:#f92672">(&lt;/span>key&lt;span style="color:#f92672">,&lt;/span> i&lt;span style="color:#f92672">,&lt;/span> e&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ThreadLocal&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> key&lt;span style="color:#f92672">,&lt;/span> Object value&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回顾我们的 get 方法，其实就是拿到&lt;strong>每个线程独有的 ThreadLocalMap&lt;/strong>&lt;/p>
&lt;p>然后再用 ThreadLocal 的当前实例，拿到 Map 中的相应的 Entry，然后就可以拿到相应的值返回出去。当然，如果 Map 为空，还会先进行 map 的创建，初始化等工作。&lt;/p>
&lt;h3 id="引发的内存泄漏分析">引发的内存泄漏分析&lt;/h3>
&lt;h4 id="引用">引用&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Object o &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Object&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 o，我们可以称之为对象引用，而 new Object()我们可以称之为在内存中产生了一个对象实例。&lt;/p>
&lt;p>当写下 &lt;code>o=null&lt;/code> 时，只是表示 o 不再指向堆中 object 的对象实例，不代表这个对象实例不存在了。&lt;/p>
&lt;h4 id="强引用">强引用&lt;/h4>
&lt;p>&lt;strong>强引用&lt;/strong>就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。&lt;/p>
&lt;h4 id="软引用">软引用&lt;/h4>
&lt;p>&lt;strong>软引用&lt;/strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象， 在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行 第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。&lt;/p>
&lt;h4 id="弱引用">弱引用&lt;/h4>
&lt;p>&lt;strong>弱引用&lt;/strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱 引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时， 无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。&lt;/p>
&lt;h4 id="虚引用">虚引用&lt;/h4>
&lt;p>&lt;strong>虚引用&lt;/strong>&lt;code>PhantomReference&lt;/code>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。&lt;/p>
&lt;h2 id="threadlocal使用不当造成内存泄露">ThreadLocal使用不当造成内存泄露&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadLocalLeakDemo&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> threadLocal &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Runnable task &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 模拟占用大量内存的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>10 &lt;span style="color:#f92672">*&lt;/span> 1024 &lt;span style="color:#f92672">*&lt;/span> 1024&lt;span style="color:#f92672">];&lt;/span> &lt;span style="color:#75715e">// 10MB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> threadLocal&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>data&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 忘记 remove()，ThreadLocal 引用还在
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Thread work done.&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 100&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread thread &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread&lt;span style="color:#f92672">(&lt;/span>task&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="问题分析">问题分析&lt;/h3>
&lt;p>每个线程都有一个 ThreadLocalMap，用来存储 ThreadLocal 的值。&lt;/p>
&lt;p>ThreadLocalMap 的 key 是 ThreadLocal 的 弱引用，value 是强引用的数据。&lt;/p>
&lt;p>如果 ThreadLocal 被 GC 回收，而没有调用 remove() 方法：&lt;/p>
&lt;p>key 会变成 null，但 value 仍然存在，导致无法清理。&lt;/p>
&lt;p>只要线程还活着（如线程池中线程），value 就不会被回收 ➜ 内存泄漏。&lt;/p>
&lt;h3 id="内存">内存&lt;/h3>
&lt;pre tabindex="0">&lt;code>Thread-1:
ThreadLocalMap:
Entry[] table = [
[0] -&amp;gt; Entry(key=ThreadLocal@abc123, value=10MB byte[])
[1] -&amp;gt; Entry(key=null, value=10MB byte[]) &amp;lt;-- key 被回收了，value 无法访问，泄漏！
...
]
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://img.hinathan.online/2025/07/WX20250330-104859.png" alt="threadLocal引用示意图">&lt;/p>
&lt;h3 id="正确使用方法">正确使用方法&lt;/h3>
&lt;h4 id="方法一手动-remove">方法一：手动 remove()&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Runnable task &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>10 &lt;span style="color:#f92672">*&lt;/span> 1024 &lt;span style="color:#f92672">*&lt;/span> 1024&lt;span style="color:#f92672">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threadLocal&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>data&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Thread work done.&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">finally&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threadLocal&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">remove&lt;/span>&lt;span style="color:#f92672">();&lt;/span> &lt;span style="color:#75715e">// 显式移除，避免内存泄漏
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="方法二使用线程池时更需注意">方法二：使用线程池时更需注意&lt;/h4>
&lt;p>线程池中的线程是复用的，如果 ThreadLocal 的值没有及时清理，会长时间占用内存&lt;/p>
&lt;h4 id="使用-try-finally-清理">使用 try-finally 清理&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threadLocal&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>someLargeObject&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行业务逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">finally&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threadLocal&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">remove&lt;/span>&lt;span style="color:#f92672">();&lt;/span> &lt;span style="color:#75715e">// 显式清除，避免泄露
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://img.hinathan.online/2025/07/687474703a2f2f75706c6f61642d.jpg" alt="threadLocal引用示意图">&lt;/p>
&lt;p>图中的虚线表示弱引用。&lt;/p>
&lt;p>这样，当把 threadlocal 变量置为 null 以后，没有任何强引用指向 threadlocal实例，所以 threadlocal 将会被 gc 回收。这样一来，ThreadLocalMap 中就会出现&lt;/p>
&lt;p>key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value，如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：&lt;code>Thread Ref&lt;/code> -&amp;gt; &lt;code>Thread&lt;/code> -&amp;gt; &lt;code>ThreaLocalMap&lt;/code> -&amp;gt; &lt;code>Entry&lt;/code> -&amp;gt; &lt;code>value&lt;/code>，而这块 value 永远不会被访问到了，所以存在着内存泄露。&lt;/p>
&lt;p>只有当前 thread 结束以后，current thread 就不会存在栈中，强引用断开，Current Thread、Map value 将全部被 GC 回收。最好的做法是不在需要使用ThreadLocal 变量后，都调用它的 remove()方法，清除数据。&lt;/p>
&lt;p>其实考察 ThreadLocal 的实现，我们可以看见，无论是 get()、set()在某些时候，调用了 expungeStaleEntry 方法用来清除 Entry 中 Key 为 null 的 Value，但是这是不及时的，也不是每次都会执行的，所以一些情况下还是会发生内存泄露。只有 remove()方法中显式调用了 expungeStaleEntry 方法。&lt;/p>
&lt;p>从表面上看内存泄漏的根源在于使用了弱引用，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？&lt;/p>
&lt;p>下面我们分两种情况讨论：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>key 使用强引用：对 ThreadLocal 对象实例的引用被置为 null 了，但是ThreadLocalMap 还持有这个 ThreadLocal 对象实例的强引用，如果没有手动删除，ThreadLocal 的对象实例不会被回收，导致 Entry 内存泄漏。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key 使用弱引用：对 ThreadLocal 对象实例的引用被被置为 null 了，由于ThreadLocalMap 持有 ThreadLocal 的弱引用，即使没有手动删除，ThreadLocal 的对象实例也会被回收。value 在下一次 ThreadLocalMap 调用 set，get，remove 都有机会被回收。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>比较两种情况，我们可以发现：由于 ThreadLocalMap 的生命周期跟 Thread 一样长，如果都没有手动删除对应 key，都会导致内存泄漏，但是使用弱引用可以多一层保障。&lt;/p>
&lt;p>因此，ThreadLocal 内存泄漏的根源是：由于 ThreadLocalMap 的生命周期跟Thread 一样长，如果没有手动删除对应 key 就会导致内存泄漏，而不是因为弱引用。&lt;/p>
&lt;h4 id="总结">总结&lt;/h4>
&lt;p>JVM 利用设置 ThreadLocalMap 的 Key 为弱引用，来避免内存泄露。&lt;/p>
&lt;p>JVM 利用调用 remove、get、set 方法的时候，回收弱引用。&lt;/p>
&lt;p>当 ThreadLocal 存储很多 Key 为 null 的 Entry 的时候，而不再去调用 remove、get、set 方法，那么将导致内存泄漏。&lt;/p>
&lt;p>使用&lt;u>线程池+ThreadLocal&lt;/u> 时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了 value 可能造成累积的情况。&lt;/p>
&lt;p>错误使用ThreadLocal 导致线程不安全。&lt;/p>
&lt;h2 id="线程间的协作">线程间的协作&lt;/h2>
&lt;p>线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值， 而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程， 而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在 while 循环中设置不满足的条件，如果条件满足则退出 while 循环，从而完成消费者的工作。却存在如下问题：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>难以确保及时性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>难以降低开销。如果降低睡眠的时间，比如休眠 1 毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="等待通知机制">等待通知机制&lt;/h3>
&lt;p>是指一个线程 A 调用了对象 O 的 wait()方法进入等待状态，而另一个线程 B 调用了对象O 的notify()或者notifyAll()方法，线程 A 收到通知后从对象O 的wait() 方法返回，进而执行后续操作。上述两个线程通过对象 O 来完成交互，而对象上的 wait()和 notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。&lt;/p>
&lt;p>&lt;code>notify()&lt;/code>通知一个在对象上等待的线程，使其从wait 方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入 WAITING 状态。&lt;/p>
&lt;p>&lt;code>notifyAll()&lt;/code>通知所有等待在该对象上的线程。&lt;/p>
&lt;p>&lt;code>wait()&lt;/code>调用该方法的线程进入 WAITING 状态,只有等待另外线程的通知或被中断才会返回。需要注意，调用 wait()方法后，会释放对象的锁。&lt;/p>
&lt;p>&lt;code>wait(long)&lt;/code>超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n 毫秒，如果没有通知就超时返回。&lt;/p>
&lt;p>&lt;code>wait (long,int)&lt;/code>对于超时时间更细粒度的控制，可以达到纳秒。&lt;/p>
&lt;h3 id="等待和通知的标准范式">等待和通知的标准范式&lt;/h3>
&lt;h4 id="等待方遵循如下原则">等待方遵循如下原则&lt;/h4>
&lt;ol>
&lt;li>获取对象的锁。&lt;/li>
&lt;li>如果条件不满足，那么调用对象的 wait()方法，被通知后仍要检查条件。&lt;/li>
&lt;li>条件满足则执行对应的逻辑。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">synchronized&lt;/span>&lt;span style="color:#f92672">(&lt;/span>对象&lt;span style="color:#f92672">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>&lt;span style="color:#f92672">(&lt;/span>条件不满足&lt;span style="color:#f92672">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 对象&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">wait&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 对应的处理逻辑
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="通知方遵循如下原则">通知方遵循如下原则&lt;/h4>
&lt;ol>
&lt;li>获得对象的锁。&lt;/li>
&lt;li>改变条件。&lt;/li>
&lt;li>通知所有等待在对象上的线程。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">synchronized&lt;/span>&lt;span style="color:#f92672">(&lt;/span>对象&lt;span style="color:#f92672">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 改变条件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 对象&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">notifyAll&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>在调用&lt;/strong> wait（）、notify()系列方法之前，&lt;strong>线程必须要获得该对象的对象级别锁&lt;/strong>，即只能在同步方法或同步块中调用wait（）方法、notify()系列方法，进入 wait（）方法后，当前线程释放锁，在从 wait（）返回前，线程与其他线程竞争重新获得锁，执行notify()系列方法的线程退出调用了notifyAll 的synchronized 代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。&lt;/p>
&lt;h4 id="notify-和-notifyall-应该用谁">notify 和 notifyAll 应该用谁&lt;/h4>
&lt;p>尽可能用 notifyAll()，谨慎使用 notify()，因为 notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程&lt;/p></description></item></channel></rss>